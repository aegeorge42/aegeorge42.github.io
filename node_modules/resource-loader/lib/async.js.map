{"version":3,"sources":["../src/async.js"],"names":["eachSeries","queue","_noop","array","iterator","callback","deferNext","i","len","length","next","err","setTimeout","onlyOnce","fn","onceWrapper","Error","callFn","apply","arguments","worker","concurrency","workers","q","_tasks","saturated","unsaturated","buffer","empty","drain","error","started","paused","push","data","_insert","kill","unshift","process","task","shift","_next","running","idle","pause","resume","w","insertAtFront","item"],"mappings":"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","file":"async.js","sourcesContent":["/**\n * Smaller version of the async library constructs.\n *\n * @namespace async\n */\n\n/**\n * Noop function\n *\n * @ignore\n * @function\n * @memberof async\n */\nfunction _noop() { /* empty */ }\n\n/**\n * Iterates an array in series.\n *\n * @memberof async\n * @param {Array.<*>} array - Array to iterate.\n * @param {function} iterator - Function to call for each element.\n * @param {function} callback - Function to call when done, or on error.\n * @param {boolean} [deferNext=false] - Break synchronous each loop by calling next with a setTimeout of 1.\n */\nexport function eachSeries(array, iterator, callback, deferNext) {\n    let i = 0;\n    const len = array.length;\n\n    (function next(err) {\n        if (err || i === len) {\n            if (callback) {\n                callback(err);\n            }\n\n            return;\n        }\n\n        if (deferNext) {\n            setTimeout(() => {\n                iterator(array[i++], next);\n            }, 1);\n        }\n        else {\n            iterator(array[i++], next);\n        }\n    })();\n}\n\n/**\n * Ensures a function is only called once.\n *\n * @ignore\n * @memberof async\n * @param {function} fn - The function to wrap.\n * @return {function} The wrapping function.\n */\nfunction onlyOnce(fn) {\n    return function onceWrapper() {\n        if (fn === null) {\n            throw new Error('Callback was already called.');\n        }\n\n        const callFn = fn;\n\n        fn = null;\n        callFn.apply(this, arguments);\n    };\n}\n\n/**\n * Async queue implementation,\n *\n * @memberof async\n * @param {function} worker - The worker function to call for each task.\n * @param {number} concurrency - How many workers to run in parrallel.\n * @return {*} The async queue object.\n */\nexport function queue(worker, concurrency) {\n    if (concurrency == null) { // eslint-disable-line no-eq-null,eqeqeq\n        concurrency = 1;\n    }\n    else if (concurrency === 0) {\n        throw new Error('Concurrency must not be zero');\n    }\n\n    let workers = 0;\n    const q = {\n        _tasks: [],\n        concurrency,\n        saturated: _noop,\n        unsaturated: _noop,\n        buffer: concurrency / 4,\n        empty: _noop,\n        drain: _noop,\n        error: _noop,\n        started: false,\n        paused: false,\n        push(data, callback) {\n            _insert(data, false, callback);\n        },\n        kill() {\n            workers = 0;\n            q.drain = _noop;\n            q.started = false;\n            q._tasks = [];\n        },\n        unshift(data, callback) {\n            _insert(data, true, callback);\n        },\n        process() {\n            while (!q.paused && workers < q.concurrency && q._tasks.length) {\n                const task = q._tasks.shift();\n\n                if (q._tasks.length === 0) {\n                    q.empty();\n                }\n\n                workers += 1;\n\n                if (workers === q.concurrency) {\n                    q.saturated();\n                }\n\n                worker(task.data, onlyOnce(_next(task)));\n            }\n        },\n        length() {\n            return q._tasks.length;\n        },\n        running() {\n            return workers;\n        },\n        idle() {\n            return q._tasks.length + workers === 0;\n        },\n        pause() {\n            if (q.paused === true) {\n                return;\n            }\n\n            q.paused = true;\n        },\n        resume() {\n            if (q.paused === false) {\n                return;\n            }\n\n            q.paused = false;\n\n            // Need to call q.process once per concurrent\n            // worker to preserve full concurrency after pause\n            for (let w = 1; w <= q.concurrency; w++) {\n                q.process();\n            }\n        },\n    };\n\n    function _insert(data, insertAtFront, callback) {\n        if (callback != null && typeof callback !== 'function') { // eslint-disable-line no-eq-null,eqeqeq\n            throw new Error('task callback must be a function');\n        }\n\n        q.started = true;\n\n        if (data == null && q.idle()) { // eslint-disable-line no-eq-null,eqeqeq\n            // call drain immediately if there are no tasks\n            setTimeout(() => q.drain(), 1);\n\n            return;\n        }\n\n        const item = {\n            data,\n            callback: typeof callback === 'function' ? callback : _noop,\n        };\n\n        if (insertAtFront) {\n            q._tasks.unshift(item);\n        }\n        else {\n            q._tasks.push(item);\n        }\n\n        setTimeout(() => q.process(), 1);\n    }\n\n    function _next(task) {\n        return function next() {\n            workers -= 1;\n\n            task.callback.apply(task, arguments);\n\n            if (arguments[0] != null) { // eslint-disable-line no-eq-null,eqeqeq\n                q.error(arguments[0], task.data);\n            }\n\n            if (workers <= (q.concurrency - q.buffer)) {\n                q.unsaturated();\n            }\n\n            if (q.idle()) {\n                q.drain();\n            }\n\n            q.process();\n        };\n    }\n\n    return q;\n}\n"]}