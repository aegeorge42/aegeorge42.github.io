{"version":3,"sources":["../src/b64.js"],"names":["encodeBinary","_keyStr","input","output","inx","length","bytebuffer","encodedCharIndexes","jnx","charCodeAt","paddingBytes","charAt","module","exports","default"],"mappings":";;;QAQgBA,Y,GAAAA,Y;AARhB,IAAMC,UAAU,mEAAhB;;AAEA;;;;;;AAMO,SAASD,YAAT,CAAsBE,KAAtB,EAA6B;AAChC,QAAIC,SAAS,EAAb;AACA,QAAIC,MAAM,CAAV;;AAEA,WAAOA,MAAMF,MAAMG,MAAnB,EAA2B;AACvB;AACA,YAAMC,aAAa,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAnB;AACA,YAAMC,qBAAqB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,CAA3B;;AAEA,aAAK,IAAIC,MAAM,CAAf,EAAkBA,MAAMF,WAAWD,MAAnC,EAA2C,EAAEG,GAA7C,EAAkD;AAC9C,gBAAIJ,MAAMF,MAAMG,MAAhB,EAAwB;AACpB;AACA;AACAC,2BAAWE,GAAX,IAAkBN,MAAMO,UAAN,CAAiBL,KAAjB,IAA0B,IAA5C;AACH,aAJD,MAKK;AACDE,2BAAWE,GAAX,IAAkB,CAAlB;AACH;AACJ;;AAED;AACA;AACAD,2BAAmB,CAAnB,IAAwBD,WAAW,CAAX,KAAiB,CAAzC;;AAEA;AACAC,2BAAmB,CAAnB,IAAyB,CAACD,WAAW,CAAX,IAAgB,GAAjB,KAAyB,CAA1B,GAAgCA,WAAW,CAAX,KAAiB,CAAzE;;AAEA;AACAC,2BAAmB,CAAnB,IAAyB,CAACD,WAAW,CAAX,IAAgB,IAAjB,KAA0B,CAA3B,GAAiCA,WAAW,CAAX,KAAiB,CAA1E;;AAEA;AACAC,2BAAmB,CAAnB,IAAwBD,WAAW,CAAX,IAAgB,IAAxC;;AAEA;AACA,YAAMI,eAAeN,OAAOF,MAAMG,MAAN,GAAe,CAAtB,CAArB;;AAEA,gBAAQK,YAAR;AACI,iBAAK,CAAL;AACI;AACAH,mCAAmB,CAAnB,IAAwB,EAAxB;AACAA,mCAAmB,CAAnB,IAAwB,EAAxB;AACA;;AAEJ,iBAAK,CAAL;AACI;AACAA,mCAAmB,CAAnB,IAAwB,EAAxB;AACA;;AAEJ;AACI,sBAbR,CAae;AAbf;;AAgBA;AACA;AACA,aAAK,IAAIC,OAAM,CAAf,EAAkBA,OAAMD,mBAAmBF,MAA3C,EAAmD,EAAEG,IAArD,EAA0D;AACtDL,sBAAUF,QAAQU,MAAR,CAAeJ,mBAAmBC,IAAnB,CAAf,CAAV;AACH;AACJ;;AAED,WAAOL,MAAP;AACH;;AAED;AACA,IAAI,OAAOS,MAAP,KAAkB,WAAtB,EAAmC;AAC/BA,WAAOC,OAAP,CAAeC,OAAf,GAAyBd,YAAzB,CAD+B,CACQ;AAC1C","file":"b64.js","sourcesContent":["const _keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n/**\n * Encodes binary into base64.\n *\n * @param {string} input The input data to encode.\n * @returns {string} The encoded base64 string\n */\nexport function encodeBinary(input) {\n    let output = '';\n    let inx = 0;\n\n    while (inx < input.length) {\n        // Fill byte buffer array\n        const bytebuffer = [0, 0, 0];\n        const encodedCharIndexes = [0, 0, 0, 0];\n\n        for (let jnx = 0; jnx < bytebuffer.length; ++jnx) {\n            if (inx < input.length) {\n                // throw away high-order byte, as documented at:\n                // https://developer.mozilla.org/En/Using_XMLHttpRequest#Handling_binary_data\n                bytebuffer[jnx] = input.charCodeAt(inx++) & 0xff;\n            }\n            else {\n                bytebuffer[jnx] = 0;\n            }\n        }\n\n        // Get each encoded character, 6 bits at a time\n        // index 1: first 6 bits\n        encodedCharIndexes[0] = bytebuffer[0] >> 2;\n\n        // index 2: second 6 bits (2 least significant bits from input byte 1 + 4 most significant bits from byte 2)\n        encodedCharIndexes[1] = ((bytebuffer[0] & 0x3) << 4) | (bytebuffer[1] >> 4);\n\n        // index 3: third 6 bits (4 least significant bits from input byte 2 + 2 most significant bits from byte 3)\n        encodedCharIndexes[2] = ((bytebuffer[1] & 0x0f) << 2) | (bytebuffer[2] >> 6);\n\n        // index 3: forth 6 bits (6 least significant bits from input byte 3)\n        encodedCharIndexes[3] = bytebuffer[2] & 0x3f;\n\n        // Determine whether padding happened, and adjust accordingly\n        const paddingBytes = inx - (input.length - 1);\n\n        switch (paddingBytes) {\n            case 2:\n                // Set last 2 characters to padding char\n                encodedCharIndexes[3] = 64;\n                encodedCharIndexes[2] = 64;\n                break;\n\n            case 1:\n                // Set last character to padding char\n                encodedCharIndexes[3] = 64;\n                break;\n\n            default:\n                break; // No padding - proceed\n        }\n\n        // Now we will grab each appropriate character out of our keystring\n        // based on our index array and append it to the output string\n        for (let jnx = 0; jnx < encodedCharIndexes.length; ++jnx) {\n            output += _keyStr.charAt(encodedCharIndexes[jnx]);\n        }\n    }\n\n    return output;\n}\n\n// Backwards compat\nif (typeof module !== 'undefined') {\n    module.exports.default = encodeBinary; // eslint-disable-line no-undef\n}\n"]}