{"version":3,"sources":["../src/Resource.js"],"names":["useXdr","window","XDomainRequest","XMLHttpRequest","tempAnchor","STATUS_NONE","STATUS_OK","STATUS_EMPTY","STATUS_IE_BUG_EMPTY","STATUS_TYPE_OK","_noop","Resource","setExtensionLoadType","extname","loadType","setExtMap","_loadTypeMap","setExtensionXhrType","xhrType","_xhrTypeMap","name","url","options","Error","_flags","_setFlag","STATUS_FLAGS","DATA_URL","indexOf","extension","_getExtension","data","crossOrigin","timeout","_determineLoadType","metadata","error","xhr","children","type","TYPE","UNKNOWN","progressChunk","_dequeue","_onLoadBinding","_elementTimer","_boundComplete","complete","bind","_boundOnError","_onError","_boundOnProgress","_onProgress","_boundOnTimeout","_onTimeout","_boundXhrOnError","_xhrOnError","_boundXhrOnTimeout","_xhrOnTimeout","_boundXhrOnAbort","_xhrOnAbort","_boundXhrOnLoad","_xhrOnLoad","onStart","Signal","onProgress","onComplete","onAfterMiddleware","_clearEvents","_finish","abort","message","xdr","src","EMPTY_GIF","firstChild","removeChild","load","cb","isLoading","isComplete","setTimeout","once","LOADING","dispatch","_determineCrossOrigin","LOAD_TYPE","IMAGE","_loadElement","AUDIO","_loadSourceElement","VIDEO","XHR","_loadXdr","_loadXhr","_hasFlag","flag","value","clearTimeout","removeEventListener","onerror","ontimeout","onprogress","onload","COMPLETE","loadElement","Image","document","createElement","skipSource","addEventListener","Audio","navigator","isCocoonJS","Array","isArray","mimeTypes","mimeType","i","length","appendChild","_createSource","_determineXhrType","open","XHR_RESPONSE_TYPE","JSON","DOCUMENT","responseType","TEXT","send","mime","source","event","target","nodeName","lengthComputable","loaded","total","reqType","status","statusText","text","responseText","BUFFER","statusType","parse","e","DOMParser","domparser","parseFromString","div","innerHTML","XML","response","responseURL","loc","origin","location","href","strictMode","samePort","port","protocol","host","hostname","ext","isDataUrl","slashIndex","substring","queryStart","hashStart","index","Math","min","lastIndexOf","toLowerCase","_getMimeFromXhrType","BLOB","DEFAULT","NONE","gif","png","bmp","jpg","jpeg","tif","tiff","webp","tga","svg","mp3","ogg","wav","mp4","webm","xhtml","html","htm","xml","tmx","tsx","json","txt","ttf","otf","map","val","toString","replace","module","exports","default"],"mappings":"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","file":"Resource.js","sourcesContent":["import parseUri from 'parse-uri';\nimport Signal from 'mini-signals';\n\n// tests if CORS is supported in XHR, if not we need to use XDR\nconst useXdr = !!(window.XDomainRequest && !('withCredentials' in (new XMLHttpRequest())));\nlet tempAnchor = null;\n\n// some status constants\nconst STATUS_NONE = 0;\nconst STATUS_OK = 200;\nconst STATUS_EMPTY = 204;\nconst STATUS_IE_BUG_EMPTY = 1223;\nconst STATUS_TYPE_OK = 2;\n\n// noop\nfunction _noop() { /* empty */ }\n\n/**\n * Manages the state and loading of a resource and all child resources.\n *\n * @class\n */\nexport class Resource {\n    /**\n     * Sets the load type to be used for a specific extension.\n     *\n     * @static\n     * @param {string} extname - The extension to set the type for, e.g. \"png\" or \"fnt\"\n     * @param {Resource.LOAD_TYPE} loadType - The load type to set it to.\n     */\n    static setExtensionLoadType(extname, loadType) {\n        setExtMap(Resource._loadTypeMap, extname, loadType);\n    }\n\n    /**\n     * Sets the load type to be used for a specific extension.\n     *\n     * @static\n     * @param {string} extname - The extension to set the type for, e.g. \"png\" or \"fnt\"\n     * @param {Resource.XHR_RESPONSE_TYPE} xhrType - The xhr type to set it to.\n     */\n    static setExtensionXhrType(extname, xhrType) {\n        setExtMap(Resource._xhrTypeMap, extname, xhrType);\n    }\n\n    /**\n     * @param {string} name - The name of the resource to load.\n     * @param {string|string[]} url - The url for this resource, for audio/video loads you can pass\n     *      an array of sources.\n     * @param {object} [options] - The options for the load.\n     * @param {string|boolean} [options.crossOrigin] - Is this request cross-origin? Default is to\n     *      determine automatically.\n     * @param {number} [options.timeout=0] - A timeout in milliseconds for the load. If the load takes\n     *      longer than this time it is cancelled and the load is considered a failure. If this value is\n     *      set to `0` then there is no explicit timeout.\n     * @param {Resource.LOAD_TYPE} [options.loadType=Resource.LOAD_TYPE.XHR] - How should this resource\n     *      be loaded?\n     * @param {Resource.XHR_RESPONSE_TYPE} [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] - How\n     *      should the data being loaded be interpreted when using XHR?\n     * @param {Resource.IMetadata} [options.metadata] - Extra configuration for middleware and the Resource object.\n     */\n    constructor(name, url, options) {\n        if (typeof name !== 'string' || typeof url !== 'string') {\n            throw new Error('Both name and url are required for constructing a resource.');\n        }\n\n        options = options || {};\n\n        /**\n         * The state flags of this resource.\n         *\n         * @private\n         * @member {number}\n         */\n        this._flags = 0;\n\n        // set data url flag, needs to be set early for some _determineX checks to work.\n        this._setFlag(Resource.STATUS_FLAGS.DATA_URL, url.indexOf('data:') === 0);\n\n        /**\n         * The name of this resource.\n         *\n         * @readonly\n         * @member {string}\n         */\n        this.name = name;\n\n        /**\n         * The url used to load this resource.\n         *\n         * @readonly\n         * @member {string}\n         */\n        this.url = url;\n\n        /**\n         * The extension used to load this resource.\n         *\n         * @readonly\n         * @member {string}\n         */\n        this.extension = this._getExtension();\n\n        /**\n         * The data that was loaded by the resource.\n         *\n         * @member {any}\n         */\n        this.data = null;\n\n        /**\n         * Is this request cross-origin? If unset, determined automatically.\n         *\n         * @member {string}\n         */\n        this.crossOrigin = options.crossOrigin === true ? 'anonymous' : options.crossOrigin;\n\n        /**\n         * A timeout in milliseconds for the load. If the load takes longer than this time\n         * it is cancelled and the load is considered a failure. If this value is set to `0`\n         * then there is no explicit timeout.\n         *\n         * @member {number}\n         */\n        this.timeout = options.timeout || 0;\n\n        /**\n         * The method of loading to use for this resource.\n         *\n         * @member {Resource.LOAD_TYPE}\n         */\n        this.loadType = options.loadType || this._determineLoadType();\n\n        /**\n         * The type used to load the resource via XHR. If unset, determined automatically.\n         *\n         * @member {string}\n         */\n        this.xhrType = options.xhrType;\n\n        /**\n         * Extra info for middleware, and controlling specifics about how the resource loads.\n         *\n         * Note that if you pass in a `loadElement`, the Resource class takes ownership of it.\n         * Meaning it will modify it as it sees fit.\n         *\n         * @member {Resource.IMetadata}\n         */\n        this.metadata = options.metadata || {};\n\n        /**\n         * The error that occurred while loading (if any).\n         *\n         * @readonly\n         * @member {Error}\n         */\n        this.error = null;\n\n        /**\n         * The XHR object that was used to load this resource. This is only set\n         * when `loadType` is `Resource.LOAD_TYPE.XHR`.\n         *\n         * @readonly\n         * @member {XMLHttpRequest}\n         */\n        this.xhr = null;\n\n        /**\n         * The child resources this resource owns.\n         *\n         * @readonly\n         * @member {Resource[]}\n         */\n        this.children = [];\n\n        /**\n         * The resource type.\n         *\n         * @readonly\n         * @member {Resource.TYPE}\n         */\n        this.type = Resource.TYPE.UNKNOWN;\n\n        /**\n         * The progress chunk owned by this resource.\n         *\n         * @readonly\n         * @member {number}\n         */\n        this.progressChunk = 0;\n\n        /**\n         * The `dequeue` method that will be used a storage place for the async queue dequeue method\n         * used privately by the loader.\n         *\n         * @private\n         * @member {function}\n         */\n        this._dequeue = _noop;\n\n        /**\n         * Used a storage place for the on load binding used privately by the loader.\n         *\n         * @private\n         * @member {function}\n         */\n        this._onLoadBinding = null;\n\n        /**\n         * The timer for element loads to check if they timeout.\n         *\n         * @private\n         * @member {number}\n         */\n        this._elementTimer = 0;\n\n        /**\n         * The `complete` function bound to this resource's context.\n         *\n         * @private\n         * @member {function}\n         */\n        this._boundComplete = this.complete.bind(this);\n\n        /**\n         * The `_onError` function bound to this resource's context.\n         *\n         * @private\n         * @member {function}\n         */\n        this._boundOnError = this._onError.bind(this);\n\n        /**\n         * The `_onProgress` function bound to this resource's context.\n         *\n         * @private\n         * @member {function}\n         */\n        this._boundOnProgress = this._onProgress.bind(this);\n\n        /**\n         * The `_onTimeout` function bound to this resource's context.\n         *\n         * @private\n         * @member {function}\n         */\n        this._boundOnTimeout = this._onTimeout.bind(this);\n\n        // xhr callbacks\n        this._boundXhrOnError = this._xhrOnError.bind(this);\n        this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this);\n        this._boundXhrOnAbort = this._xhrOnAbort.bind(this);\n        this._boundXhrOnLoad = this._xhrOnLoad.bind(this);\n\n        /**\n         * Dispatched when the resource beings to load.\n         *\n         * The callback looks like {@link Resource.OnStartSignal}.\n         *\n         * @member {Signal<Resource.OnStartSignal>}\n         */\n        this.onStart = new Signal();\n\n        /**\n         * Dispatched each time progress of this resource load updates.\n         * Not all resources types and loader systems can support this event\n         * so sometimes it may not be available. If the resource\n         * is being loaded on a modern browser, using XHR, and the remote server\n         * properly sets Content-Length headers, then this will be available.\n         *\n         * The callback looks like {@link Resource.OnProgressSignal}.\n         *\n         * @member {Signal<Resource.OnProgressSignal>}\n         */\n        this.onProgress = new Signal();\n\n        /**\n         * Dispatched once this resource has loaded, if there was an error it will\n         * be in the `error` property.\n         *\n         * The callback looks like {@link Resource.OnCompleteSignal}.\n         *\n         * @member {Signal<Resource.OnCompleteSignal>}\n         */\n        this.onComplete = new Signal();\n\n        /**\n         * Dispatched after this resource has had all the *after* middleware run on it.\n         *\n         * The callback looks like {@link Resource.OnCompleteSignal}.\n         *\n         * @member {Signal<Resource.OnCompleteSignal>}\n         */\n        this.onAfterMiddleware = new Signal();\n    }\n\n    /**\n     * When the resource starts to load.\n     *\n     * @memberof Resource\n     * @callback OnStartSignal\n     * @param {Resource} resource - The resource that the event happened on.\n     */\n\n    /**\n     * When the resource reports loading progress.\n     *\n     * @memberof Resource\n     * @callback OnProgressSignal\n     * @param {Resource} resource - The resource that the event happened on.\n     * @param {number} percentage - The progress of the load in the range [0, 1].\n     */\n\n    /**\n     * When the resource finishes loading.\n     *\n     * @memberof Resource\n     * @callback OnCompleteSignal\n     * @param {Resource} resource - The resource that the event happened on.\n     */\n\n    /**\n     * @memberof Resource\n     * @typedef {object} IMetadata\n     * @property {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [loadElement=null] - The\n     *      element to use for loading, instead of creating one.\n     * @property {boolean} [skipSource=false] - Skips adding source(s) to the load element. This\n     *      is useful if you want to pass in a `loadElement` that you already added load sources to.\n     * @property {string|string[]} [mimeType] - The mime type to use for the source element\n     *      of a video/audio elment. If the urls are an array, you can pass this as an array as well\n     *      where each index is the mime type to use for the corresponding url index.\n     */\n\n    /**\n     * Stores whether or not this url is a data url.\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    get isDataUrl() {\n        return this._hasFlag(Resource.STATUS_FLAGS.DATA_URL);\n    }\n\n    /**\n     * Describes if this resource has finished loading. Is true when the resource has completely\n     * loaded.\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    get isComplete() {\n        return this._hasFlag(Resource.STATUS_FLAGS.COMPLETE);\n    }\n\n    /**\n     * Describes if this resource is currently loading. Is true when the resource starts loading,\n     * and is false again when complete.\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    get isLoading() {\n        return this._hasFlag(Resource.STATUS_FLAGS.LOADING);\n    }\n\n    /**\n     * Marks the resource as complete.\n     *\n     */\n    complete() {\n        this._clearEvents();\n        this._finish();\n    }\n\n    /**\n     * Aborts the loading of this resource, with an optional message.\n     *\n     * @param {string} message - The message to use for the error\n     */\n    abort(message) {\n        // abort can be called multiple times, ignore subsequent calls.\n        if (this.error) {\n            return;\n        }\n\n        // store error\n        this.error = new Error(message);\n\n        // clear events before calling aborts\n        this._clearEvents();\n\n        // abort the actual loading\n        if (this.xhr) {\n            this.xhr.abort();\n        }\n        else if (this.xdr) {\n            this.xdr.abort();\n        }\n        else if (this.data) {\n            // single source\n            if (this.data.src) {\n                this.data.src = Resource.EMPTY_GIF;\n            }\n            // multi-source\n            else {\n                while (this.data.firstChild) {\n                    this.data.removeChild(this.data.firstChild);\n                }\n            }\n        }\n\n        // done now.\n        this._finish();\n    }\n\n    /**\n     * Kicks off loading of this resource. This method is asynchronous.\n     *\n     * @param {Resource.OnCompleteSignal} [cb] - Optional callback to call once the resource is loaded.\n     */\n    load(cb) {\n        if (this.isLoading) {\n            return;\n        }\n\n        if (this.isComplete) {\n            if (cb) {\n                setTimeout(() => cb(this), 1);\n            }\n\n            return;\n        }\n        else if (cb) {\n            this.onComplete.once(cb);\n        }\n\n        this._setFlag(Resource.STATUS_FLAGS.LOADING, true);\n\n        this.onStart.dispatch(this);\n\n        // if unset, determine the value\n        if (this.crossOrigin === false || typeof this.crossOrigin !== 'string') {\n            this.crossOrigin = this._determineCrossOrigin(this.url);\n        }\n\n        switch (this.loadType) {\n            case Resource.LOAD_TYPE.IMAGE:\n                this.type = Resource.TYPE.IMAGE;\n                this._loadElement('image');\n                break;\n\n            case Resource.LOAD_TYPE.AUDIO:\n                this.type = Resource.TYPE.AUDIO;\n                this._loadSourceElement('audio');\n                break;\n\n            case Resource.LOAD_TYPE.VIDEO:\n                this.type = Resource.TYPE.VIDEO;\n                this._loadSourceElement('video');\n                break;\n\n            case Resource.LOAD_TYPE.XHR:\n                /* falls through */\n            default:\n                if (useXdr && this.crossOrigin) {\n                    this._loadXdr();\n                }\n                else {\n                    this._loadXhr();\n                }\n                break;\n        }\n    }\n\n    /**\n     * Checks if the flag is set.\n     *\n     * @private\n     * @param {number} flag - The flag to check.\n     * @return {boolean} True if the flag is set.\n     */\n    _hasFlag(flag) {\n        return (this._flags & flag) !== 0;\n    }\n\n    /**\n     * (Un)Sets the flag.\n     *\n     * @private\n     * @param {number} flag - The flag to (un)set.\n     * @param {boolean} value - Whether to set or (un)set the flag.\n     */\n    _setFlag(flag, value) {\n        this._flags = value ? (this._flags | flag) : (this._flags & ~flag);\n    }\n\n    /**\n     * Clears all the events from the underlying loading source.\n     *\n     * @private\n     */\n    _clearEvents() {\n        clearTimeout(this._elementTimer);\n\n        if (this.data && this.data.removeEventListener) {\n            this.data.removeEventListener('error', this._boundOnError, false);\n            this.data.removeEventListener('load', this._boundComplete, false);\n            this.data.removeEventListener('progress', this._boundOnProgress, false);\n            this.data.removeEventListener('canplaythrough', this._boundComplete, false);\n        }\n\n        if (this.xhr) {\n            if (this.xhr.removeEventListener) {\n                this.xhr.removeEventListener('error', this._boundXhrOnError, false);\n                this.xhr.removeEventListener('timeout', this._boundXhrOnTimeout, false);\n                this.xhr.removeEventListener('abort', this._boundXhrOnAbort, false);\n                this.xhr.removeEventListener('progress', this._boundOnProgress, false);\n                this.xhr.removeEventListener('load', this._boundXhrOnLoad, false);\n            }\n            else {\n                this.xhr.onerror = null;\n                this.xhr.ontimeout = null;\n                this.xhr.onprogress = null;\n                this.xhr.onload = null;\n            }\n        }\n    }\n\n    /**\n     * Finalizes the load.\n     *\n     * @private\n     */\n    _finish() {\n        if (this.isComplete) {\n            throw new Error('Complete called again for an already completed resource.');\n        }\n\n        this._setFlag(Resource.STATUS_FLAGS.COMPLETE, true);\n        this._setFlag(Resource.STATUS_FLAGS.LOADING, false);\n\n        this.onComplete.dispatch(this);\n    }\n\n    /**\n     * Loads this resources using an element that has a single source,\n     * like an HTMLImageElement.\n     *\n     * @private\n     * @param {string} type - The type of element to use.\n     */\n    _loadElement(type) {\n        if (this.metadata.loadElement) {\n            this.data = this.metadata.loadElement;\n        }\n        else if (type === 'image' && typeof window.Image !== 'undefined') {\n            this.data = new Image();\n        }\n        else {\n            this.data = document.createElement(type);\n        }\n\n        if (this.crossOrigin) {\n            this.data.crossOrigin = this.crossOrigin;\n        }\n\n        if (!this.metadata.skipSource) {\n            this.data.src = this.url;\n        }\n\n        this.data.addEventListener('error', this._boundOnError, false);\n        this.data.addEventListener('load', this._boundComplete, false);\n        this.data.addEventListener('progress', this._boundOnProgress, false);\n\n        if (this.timeout) {\n            this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);\n        }\n    }\n\n    /**\n     * Loads this resources using an element that has multiple sources,\n     * like an HTMLAudioElement or HTMLVideoElement.\n     *\n     * @private\n     * @param {string} type - The type of element to use.\n     */\n    _loadSourceElement(type) {\n        if (this.metadata.loadElement) {\n            this.data = this.metadata.loadElement;\n        }\n        else if (type === 'audio' && typeof window.Audio !== 'undefined') {\n            this.data = new Audio();\n        }\n        else {\n            this.data = document.createElement(type);\n        }\n\n        if (this.data === null) {\n            this.abort(`Unsupported element: ${type}`);\n\n            return;\n        }\n\n        if (this.crossOrigin) {\n            this.data.crossOrigin = this.crossOrigin;\n        }\n\n        if (!this.metadata.skipSource) {\n            // support for CocoonJS Canvas+ runtime, lacks document.createElement('source')\n            if (navigator.isCocoonJS) {\n                this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;\n            }\n            else if (Array.isArray(this.url)) {\n                const mimeTypes = this.metadata.mimeType;\n\n                for (let i = 0; i < this.url.length; ++i) {\n                    this.data.appendChild(\n                        this._createSource(type, this.url[i], Array.isArray(mimeTypes) ? mimeTypes[i] : mimeTypes)\n                    );\n                }\n            }\n            else {\n                const mimeTypes = this.metadata.mimeType;\n\n                this.data.appendChild(\n                    this._createSource(type, this.url, Array.isArray(mimeTypes) ? mimeTypes[0] : mimeTypes)\n                );\n            }\n        }\n\n        this.data.addEventListener('error', this._boundOnError, false);\n        this.data.addEventListener('load', this._boundComplete, false);\n        this.data.addEventListener('progress', this._boundOnProgress, false);\n        this.data.addEventListener('canplaythrough', this._boundComplete, false);\n\n        this.data.load();\n\n        if (this.timeout) {\n            this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);\n        }\n    }\n\n    /**\n     * Loads this resources using an XMLHttpRequest.\n     *\n     * @private\n     */\n    _loadXhr() {\n        // if unset, determine the value\n        if (typeof this.xhrType !== 'string') {\n            this.xhrType = this._determineXhrType();\n        }\n\n        const xhr = this.xhr = new XMLHttpRequest();\n\n        // set the request type and url\n        xhr.open('GET', this.url, true);\n\n        xhr.timeout = this.timeout;\n\n        // load json as text and parse it ourselves. We do this because some browsers\n        // *cough* safari *cough* can't deal with it.\n        if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON || this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {\n            xhr.responseType = Resource.XHR_RESPONSE_TYPE.TEXT;\n        }\n        else {\n            xhr.responseType = this.xhrType;\n        }\n\n        xhr.addEventListener('error', this._boundXhrOnError, false);\n        xhr.addEventListener('timeout', this._boundXhrOnTimeout, false);\n        xhr.addEventListener('abort', this._boundXhrOnAbort, false);\n        xhr.addEventListener('progress', this._boundOnProgress, false);\n        xhr.addEventListener('load', this._boundXhrOnLoad, false);\n\n        xhr.send();\n    }\n\n    /**\n     * Loads this resources using an XDomainRequest. This is here because we need to support IE9 (gross).\n     *\n     * @private\n     */\n    _loadXdr() {\n        // if unset, determine the value\n        if (typeof this.xhrType !== 'string') {\n            this.xhrType = this._determineXhrType();\n        }\n\n        const xdr = this.xhr = new XDomainRequest(); // eslint-disable-line no-undef\n\n        // XDomainRequest has a few quirks. Occasionally it will abort requests\n        // A way to avoid this is to make sure ALL callbacks are set even if not used\n        // More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9\n        xdr.timeout = this.timeout || 5000; // XDR needs a timeout value or it breaks in IE9\n\n        xdr.onerror = this._boundXhrOnError;\n        xdr.ontimeout = this._boundXhrOnTimeout;\n        xdr.onprogress = this._boundOnProgress;\n        xdr.onload = this._boundXhrOnLoad;\n\n        xdr.open('GET', this.url, true);\n\n        // Note: The xdr.send() call is wrapped in a timeout to prevent an\n        // issue with the interface where some requests are lost if multiple\n        // XDomainRequests are being sent at the same time.\n        // Some info here: https://github.com/photonstorm/phaser/issues/1248\n        setTimeout(() => xdr.send(), 1);\n    }\n\n    /**\n     * Creates a source used in loading via an element.\n     *\n     * @private\n     * @param {string} type - The element type (video or audio).\n     * @param {string} url - The source URL to load from.\n     * @param {string} [mime] - The mime type of the video\n     * @return {HTMLSourceElement} The source element.\n     */\n    _createSource(type, url, mime) {\n        if (!mime) {\n            mime = `${type}/${this._getExtension(url)}`;\n        }\n\n        const source = document.createElement('source');\n\n        source.src = url;\n        source.type = mime;\n\n        return source;\n    }\n\n    /**\n     * Called if a load errors out.\n     *\n     * @param {Event} event - The error event from the element that emits it.\n     * @private\n     */\n    _onError(event) {\n        this.abort(`Failed to load element using: ${event.target.nodeName}`);\n    }\n\n    /**\n     * Called if a load progress event fires for an element or xhr/xdr.\n     *\n     * @private\n     * @param {XMLHttpRequestProgressEvent|Event} event - Progress event.\n     */\n    _onProgress(event) {\n        if (event && event.lengthComputable) {\n            this.onProgress.dispatch(this, event.loaded / event.total);\n        }\n    }\n\n    /**\n     * Called if a timeout event fires for an element.\n     *\n     * @private\n     */\n    _onTimeout() {\n        this.abort(`Load timed out.`);\n    }\n\n    /**\n     * Called if an error event fires for xhr/xdr.\n     *\n     * @private\n     */\n    _xhrOnError() {\n        const xhr = this.xhr;\n\n        this.abort(`${reqType(xhr)} Request failed. Status: ${xhr.status}, text: \"${xhr.statusText}\"`);\n    }\n\n    /**\n     * Called if an error event fires for xhr/xdr.\n     *\n     * @private\n     */\n    _xhrOnTimeout() {\n        const xhr = this.xhr;\n\n        this.abort(`${reqType(xhr)} Request timed out.`);\n    }\n\n    /**\n     * Called if an abort event fires for xhr/xdr.\n     *\n     * @private\n     */\n    _xhrOnAbort() {\n        const xhr = this.xhr;\n\n        this.abort(`${reqType(xhr)} Request was aborted by the user.`);\n    }\n\n    /**\n     * Called when data successfully loads from an xhr/xdr request.\n     *\n     * @private\n     * @param {XMLHttpRequestLoadEvent|Event} event - Load event\n     */\n    _xhrOnLoad() {\n        const xhr = this.xhr;\n        let text = '';\n        let status = typeof xhr.status === 'undefined' ? STATUS_OK : xhr.status; // XDR has no `.status`, assume 200.\n\n        // responseText is accessible only if responseType is '' or 'text' and on older browsers\n        if (xhr.responseType === '' || xhr.responseType === 'text' || typeof xhr.responseType === 'undefined') {\n            text = xhr.responseText;\n        }\n\n        // status can be 0 when using the `file://` protocol so we also check if a response is set.\n        // If it has a response, we assume 200; otherwise a 0 status code with no contents is an aborted request.\n        if (status === STATUS_NONE && (text.length > 0 || xhr.responseType === Resource.XHR_RESPONSE_TYPE.BUFFER)) {\n            status = STATUS_OK;\n        }\n        // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n        else if (status === STATUS_IE_BUG_EMPTY) {\n            status = STATUS_EMPTY;\n        }\n\n        const statusType = (status / 100) | 0;\n\n        if (statusType === STATUS_TYPE_OK) {\n            // if text, just return it\n            if (this.xhrType === Resource.XHR_RESPONSE_TYPE.TEXT) {\n                this.data = text;\n                this.type = Resource.TYPE.TEXT;\n            }\n            // if json, parse into json object\n            else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON) {\n                try {\n                    this.data = JSON.parse(text);\n                    this.type = Resource.TYPE.JSON;\n                }\n                catch (e) {\n                    this.abort(`Error trying to parse loaded json: ${e}`);\n\n                    return;\n                }\n            }\n            // if xml, parse into an xml document or div element\n            else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {\n                try {\n                    if (window.DOMParser) {\n                        const domparser = new DOMParser();\n\n                        this.data = domparser.parseFromString(text, 'text/xml');\n                    }\n                    else {\n                        const div = document.createElement('div');\n\n                        div.innerHTML = text;\n\n                        this.data = div;\n                    }\n\n                    this.type = Resource.TYPE.XML;\n                }\n                catch (e) {\n                    this.abort(`Error trying to parse loaded xml: ${e}`);\n\n                    return;\n                }\n            }\n            // other types just return the response\n            else {\n                this.data = xhr.response || text;\n            }\n        }\n        else {\n            this.abort(`[${xhr.status}] ${xhr.statusText}: ${xhr.responseURL}`);\n\n            return;\n        }\n\n        this.complete();\n    }\n\n    /**\n     * Sets the `crossOrigin` property for this resource based on if the url\n     * for this resource is cross-origin. If crossOrigin was manually set, this\n     * function does nothing.\n     *\n     * @private\n     * @param {string} url - The url to test.\n     * @param {object} [loc=window.location] - The location object to test against.\n     * @return {string} The crossOrigin value to use (or empty string for none).\n     */\n    _determineCrossOrigin(url, loc) {\n        // data: and javascript: urls are considered same-origin\n        if (url.indexOf('data:') === 0) {\n            return '';\n        }\n\n        // A sandboxed iframe without the 'allow-same-origin' attribute will have a special\n        // origin designed not to match window.location.origin, and will always require\n        // crossOrigin requests regardless of whether the location matches.\n        if (window.origin !== window.location.origin) {\n            return 'anonymous';\n        }\n\n        // default is window.location\n        loc = loc || window.location;\n\n        if (!tempAnchor) {\n            tempAnchor = document.createElement('a');\n        }\n\n        // let the browser determine the full href for the url of this resource and then\n        // parse with the node url lib, we can't use the properties of the anchor element\n        // because they don't work in IE9 :(\n        tempAnchor.href = url;\n        url = parseUri(tempAnchor.href, { strictMode: true });\n\n        const samePort = (!url.port && loc.port === '') || (url.port === loc.port);\n        const protocol = url.protocol ? `${url.protocol}:` : '';\n\n        // if cross origin\n        if (url.host !== loc.hostname || !samePort || protocol !== loc.protocol) {\n            return 'anonymous';\n        }\n\n        return '';\n    }\n\n    /**\n     * Determines the responseType of an XHR request based on the extension of the\n     * resource being loaded.\n     *\n     * @private\n     * @return {Resource.XHR_RESPONSE_TYPE} The responseType to use.\n     */\n    _determineXhrType() {\n        return Resource._xhrTypeMap[this.extension] || Resource.XHR_RESPONSE_TYPE.TEXT;\n    }\n\n    /**\n     * Determines the loadType of a resource based on the extension of the\n     * resource being loaded.\n     *\n     * @private\n     * @return {Resource.LOAD_TYPE} The loadType to use.\n     */\n    _determineLoadType() {\n        return Resource._loadTypeMap[this.extension] || Resource.LOAD_TYPE.XHR;\n    }\n\n    /**\n     * Extracts the extension (sans '.') of the file being loaded by the resource.\n     *\n     * @private\n     * @return {string} The extension.\n     */\n    _getExtension() {\n        let url = this.url;\n        let ext = '';\n\n        if (this.isDataUrl) {\n            const slashIndex = url.indexOf('/');\n\n            ext = url.substring(slashIndex + 1, url.indexOf(';', slashIndex));\n        }\n        else {\n            const queryStart = url.indexOf('?');\n            const hashStart = url.indexOf('#');\n            const index = Math.min(\n                queryStart > -1 ? queryStart : url.length,\n                hashStart > -1 ? hashStart : url.length\n            );\n\n            url = url.substring(0, index);\n            ext = url.substring(url.lastIndexOf('.') + 1);\n        }\n\n        return ext.toLowerCase();\n    }\n\n    /**\n     * Determines the mime type of an XHR request based on the responseType of\n     * resource being loaded.\n     *\n     * @private\n     * @param {Resource.XHR_RESPONSE_TYPE} type - The type to get a mime type for.\n     * @return {string} The mime type to use.\n     */\n    _getMimeFromXhrType(type) {\n        switch (type) {\n            case Resource.XHR_RESPONSE_TYPE.BUFFER:\n                return 'application/octet-binary';\n\n            case Resource.XHR_RESPONSE_TYPE.BLOB:\n                return 'application/blob';\n\n            case Resource.XHR_RESPONSE_TYPE.DOCUMENT:\n                return 'application/xml';\n\n            case Resource.XHR_RESPONSE_TYPE.JSON:\n                return 'application/json';\n\n            case Resource.XHR_RESPONSE_TYPE.DEFAULT:\n            case Resource.XHR_RESPONSE_TYPE.TEXT:\n                /* falls through */\n            default:\n                return 'text/plain';\n        }\n    }\n}\n\n/**\n * The types of resources a resource could represent.\n *\n * @static\n * @readonly\n * @enum {number}\n */\nResource.STATUS_FLAGS = {\n    NONE:       0,\n    DATA_URL:   (1 << 0),\n    COMPLETE:   (1 << 1),\n    LOADING:    (1 << 2),\n};\n\n/**\n * The types of resources a resource could represent.\n *\n * @static\n * @readonly\n * @enum {number}\n */\nResource.TYPE = {\n    UNKNOWN:    0,\n    JSON:       1,\n    XML:        2,\n    IMAGE:      3,\n    AUDIO:      4,\n    VIDEO:      5,\n    TEXT:       6,\n};\n\n/**\n * The types of loading a resource can use.\n *\n * @static\n * @readonly\n * @enum {number}\n */\nResource.LOAD_TYPE = {\n    /** Uses XMLHttpRequest to load the resource. */\n    XHR:    1,\n    /** Uses an `Image` object to load the resource. */\n    IMAGE:  2,\n    /** Uses an `Audio` object to load the resource. */\n    AUDIO:  3,\n    /** Uses a `Video` object to load the resource. */\n    VIDEO:  4,\n};\n\n/**\n * The XHR ready states, used internally.\n *\n * @static\n * @readonly\n * @enum {string}\n */\nResource.XHR_RESPONSE_TYPE = {\n    /** string */\n    DEFAULT:    'text',\n    /** ArrayBuffer */\n    BUFFER:     'arraybuffer',\n    /** Blob */\n    BLOB:       'blob',\n    /** Document */\n    DOCUMENT:   'document',\n    /** Object */\n    JSON:       'json',\n    /** String */\n    TEXT:       'text',\n};\n\nResource._loadTypeMap = {\n    // images\n    gif:        Resource.LOAD_TYPE.IMAGE,\n    png:        Resource.LOAD_TYPE.IMAGE,\n    bmp:        Resource.LOAD_TYPE.IMAGE,\n    jpg:        Resource.LOAD_TYPE.IMAGE,\n    jpeg:       Resource.LOAD_TYPE.IMAGE,\n    tif:        Resource.LOAD_TYPE.IMAGE,\n    tiff:       Resource.LOAD_TYPE.IMAGE,\n    webp:       Resource.LOAD_TYPE.IMAGE,\n    tga:        Resource.LOAD_TYPE.IMAGE,\n    svg:        Resource.LOAD_TYPE.IMAGE,\n    'svg+xml':  Resource.LOAD_TYPE.IMAGE, // for SVG data urls\n\n    // audio\n    mp3:        Resource.LOAD_TYPE.AUDIO,\n    ogg:        Resource.LOAD_TYPE.AUDIO,\n    wav:        Resource.LOAD_TYPE.AUDIO,\n\n    // videos\n    mp4:        Resource.LOAD_TYPE.VIDEO,\n    webm:       Resource.LOAD_TYPE.VIDEO,\n};\n\nResource._xhrTypeMap = {\n    // xml\n    xhtml:      Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    html:       Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    htm:        Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    xml:        Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    tmx:        Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    svg:        Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n\n    // This was added to handle Tiled Tileset XML, but .tsx is also a TypeScript React Component.\n    // Since it is way less likely for people to be loading TypeScript files instead of Tiled files,\n    // this should probably be fine.\n    tsx:        Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n\n    // images\n    gif:        Resource.XHR_RESPONSE_TYPE.BLOB,\n    png:        Resource.XHR_RESPONSE_TYPE.BLOB,\n    bmp:        Resource.XHR_RESPONSE_TYPE.BLOB,\n    jpg:        Resource.XHR_RESPONSE_TYPE.BLOB,\n    jpeg:       Resource.XHR_RESPONSE_TYPE.BLOB,\n    tif:        Resource.XHR_RESPONSE_TYPE.BLOB,\n    tiff:       Resource.XHR_RESPONSE_TYPE.BLOB,\n    webp:       Resource.XHR_RESPONSE_TYPE.BLOB,\n    tga:        Resource.XHR_RESPONSE_TYPE.BLOB,\n\n    // json\n    json:       Resource.XHR_RESPONSE_TYPE.JSON,\n\n    // text\n    text:       Resource.XHR_RESPONSE_TYPE.TEXT,\n    txt:        Resource.XHR_RESPONSE_TYPE.TEXT,\n\n    // fonts\n    ttf:        Resource.XHR_RESPONSE_TYPE.BUFFER,\n    otf:        Resource.XHR_RESPONSE_TYPE.BUFFER,\n};\n\n// We can't set the `src` attribute to empty string, so on abort we set it to this 1px transparent gif\nResource.EMPTY_GIF = 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==';\n\n/**\n * Quick helper to set a value on one of the extension maps. Ensures there is no\n * dot at the start of the extension.\n *\n * @ignore\n * @param {object} map - The map to set on.\n * @param {string} extname - The extension (or key) to set.\n * @param {number} val - The value to set.\n */\nfunction setExtMap(map, extname, val) {\n    if (extname && extname.indexOf('.') === 0) {\n        extname = extname.substring(1);\n    }\n\n    if (!extname) {\n        return;\n    }\n\n    map[extname] = val;\n}\n\n/**\n * Quick helper to get string xhr type.\n *\n * @ignore\n * @param {XMLHttpRequest|XDomainRequest} xhr - The request to check.\n * @return {string} The type.\n */\nfunction reqType(xhr) {\n    return xhr.toString().replace('object ', '');\n}\n\n// Backwards compat\nif (typeof module !== 'undefined') {\n    module.exports.default = Resource; // eslint-disable-line no-undef\n}\n"]}