{"version":3,"sources":["../../src/mesh/Rope.js"],"names":["Rope","texture","points","vertices","Float32Array","length","uvs","colors","indices","Uint16Array","autoUpdate","refresh","_refresh","_texture","_uvs","total","i","index","amount","dirty","indexDirty","multiplyUvs","refreshVertices","lastPoint","nextPoint","perpX","perpY","point","x","y","ratio","perpLength","Math","sqrt","num","height","updateTransform","containerUpdateTransform"],"mappings":"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","file":"Rope.js","sourcesContent":["import Mesh from './Mesh';\n\n/**\n * The rope allows you to draw a texture across several points and them manipulate these points\n *\n *```js\n * for (let i = 0; i < 20; i++) {\n *     points.push(new PIXI.Point(i * 50, 0));\n * };\n * let rope = new PIXI.Rope(PIXI.Texture.fromImage(\"snake.png\"), points);\n *  ```\n *\n * @class\n * @extends PIXI.mesh.Mesh\n * @memberof PIXI.mesh\n *\n */\nexport default class Rope extends Mesh\n{\n    /**\n     * @param {PIXI.Texture} texture - The texture to use on the rope.\n     * @param {PIXI.Point[]} points - An array of {@link PIXI.Point} objects to construct this rope.\n     */\n    constructor(texture, points)\n    {\n        super(texture);\n\n        /**\n         * An array of points that determine the rope\n         *\n         * @member {PIXI.Point[]}\n         */\n        this.points = points;\n\n        /**\n         * An array of vertices used to construct this rope.\n         *\n         * @member {Float32Array}\n         */\n        this.vertices = new Float32Array(points.length * 4);\n\n        /**\n         * The WebGL Uvs of the rope.\n         *\n         * @member {Float32Array}\n         */\n        this.uvs = new Float32Array(points.length * 4);\n\n        /**\n         * An array containing the color components\n         *\n         * @member {Float32Array}\n         */\n        this.colors = new Float32Array(points.length * 2);\n\n        /**\n         * An array containing the indices of the vertices\n         *\n         * @member {Uint16Array}\n         */\n        this.indices = new Uint16Array(points.length * 2);\n\n        /**\n         * refreshes vertices on every updateTransform\n         * @member {boolean}\n         * @default true\n         */\n        this.autoUpdate = true;\n\n        this.refresh();\n    }\n\n    /**\n     * Refreshes\n     *\n     */\n    _refresh()\n    {\n        const points = this.points;\n\n        // if too little points, or texture hasn't got UVs set yet just move on.\n        if (points.length < 1 || !this._texture._uvs)\n        {\n            return;\n        }\n\n        // if the number of points has changed we will need to recreate the arraybuffers\n        if (this.vertices.length / 4 !== points.length)\n        {\n            this.vertices = new Float32Array(points.length * 4);\n            this.uvs = new Float32Array(points.length * 4);\n            this.colors = new Float32Array(points.length * 2);\n            this.indices = new Uint16Array(points.length * 2);\n        }\n\n        const uvs = this.uvs;\n\n        const indices = this.indices;\n        const colors = this.colors;\n\n        uvs[0] = 0;\n        uvs[1] = 0;\n        uvs[2] = 0;\n        uvs[3] = 1;\n\n        colors[0] = 1;\n        colors[1] = 1;\n\n        indices[0] = 0;\n        indices[1] = 1;\n\n        const total = points.length;\n\n        for (let i = 1; i < total; i++)\n        {\n            // time to do some smart drawing!\n            let index = i * 4;\n            const amount = i / (total - 1);\n\n            uvs[index] = amount;\n            uvs[index + 1] = 0;\n\n            uvs[index + 2] = amount;\n            uvs[index + 3] = 1;\n\n            index = i * 2;\n            colors[index] = 1;\n            colors[index + 1] = 1;\n\n            index = i * 2;\n            indices[index] = index;\n            indices[index + 1] = index + 1;\n        }\n\n        // ensure that the changes are uploaded\n        this.dirty++;\n        this.indexDirty++;\n\n        this.multiplyUvs();\n        this.refreshVertices();\n    }\n\n    /**\n     * refreshes vertices of Rope mesh\n     */\n    refreshVertices()\n    {\n        const points = this.points;\n\n        if (points.length < 1)\n        {\n            return;\n        }\n\n        let lastPoint = points[0];\n        let nextPoint;\n        let perpX = 0;\n        let perpY = 0;\n\n        // this.count -= 0.2;\n\n        const vertices = this.vertices;\n        const total = points.length;\n\n        for (let i = 0; i < total; i++)\n        {\n            const point = points[i];\n            const index = i * 4;\n\n            if (i < points.length - 1)\n            {\n                nextPoint = points[i + 1];\n            }\n            else\n            {\n                nextPoint = point;\n            }\n\n            perpY = -(nextPoint.x - lastPoint.x);\n            perpX = nextPoint.y - lastPoint.y;\n\n            let ratio = (1 - (i / (total - 1))) * 10;\n\n            if (ratio > 1)\n            {\n                ratio = 1;\n            }\n\n            const perpLength = Math.sqrt((perpX * perpX) + (perpY * perpY));\n            const num = this._texture.height / 2; // (20 + Math.abs(Math.sin((i + this.count) * 0.3) * 50) )* ratio;\n\n            perpX /= perpLength;\n            perpY /= perpLength;\n\n            perpX *= num;\n            perpY *= num;\n\n            vertices[index] = point.x + perpX;\n            vertices[index + 1] = point.y + perpY;\n            vertices[index + 2] = point.x - perpX;\n            vertices[index + 3] = point.y - perpY;\n\n            lastPoint = point;\n        }\n    }\n\n    /**\n     * Updates the object transform for rendering\n     *\n     * @private\n     */\n    updateTransform()\n    {\n        if (this.autoUpdate)\n        {\n            this.refreshVertices();\n        }\n        this.containerUpdateTransform();\n    }\n\n}\n"]}