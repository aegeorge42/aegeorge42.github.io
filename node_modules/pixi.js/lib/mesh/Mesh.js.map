{"version":3,"sources":["../../src/mesh/Mesh.js"],"names":["core","tempPoint","Point","tempPolygon","Polygon","Mesh","texture","vertices","uvs","indices","drawMode","_texture","EMPTY","Float32Array","Uint16Array","dirty","indexDirty","vertexDirty","autoUpdate","blendMode","BLEND_MODES","NORMAL","canvasPadding","settings","MESH_CANVAS_PADDING","DRAW_MODES","TRIANGLE_MESH","shader","tintRgb","_glDatas","_uvTransform","TextureMatrix","uploadUvTransform","pluginName","_renderWebGL","renderer","refresh","setObjectRenderer","plugins","render","_renderCanvas","_onTextureUpdate","multiplyUvs","forceUpdate","update","_refresh","_calculateBounds","_bounds","addVertices","transform","length","containsPoint","point","getBounds","contains","x","y","worldTransform","applyInverse","points","len","step","TRIANGLES","i","ind0","ind1","ind2","destroy","options","id","data","vertexBuffer","indexBuffer","uvBuffer","vao","value","baseTexture","hasLoaded","once","utils","rgb2hex","hex2rgb","Container"],"mappings":"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","file":"Mesh.js","sourcesContent":["import * as core from '../core';\nimport Texture from '../core/textures/Texture';\n\nconst tempPoint = new core.Point();\nconst tempPolygon = new core.Polygon();\n\n/**\n * Base mesh class\n * @class\n * @extends PIXI.Container\n * @memberof PIXI.mesh\n */\nexport default class Mesh extends core.Container\n{\n    /**\n     * @param {PIXI.Texture} texture - The texture to use\n     * @param {Float32Array} [vertices] - if you want to specify the vertices\n     * @param {Float32Array} [uvs] - if you want to specify the uvs\n     * @param {Uint16Array} [indices] - if you want to specify the indices\n     * @param {number} [drawMode] - the drawMode, can be any of the Mesh.DRAW_MODES consts\n     */\n    constructor(texture, vertices, uvs, indices, drawMode)\n    {\n        super();\n\n        /**\n         * The texture of the Mesh\n         *\n         * @member {PIXI.Texture}\n         * @default PIXI.Texture.EMPTY\n         * @private\n         */\n        this._texture = texture || Texture.EMPTY;\n\n        /**\n         * The Uvs of the Mesh\n         *\n         * @member {Float32Array}\n         */\n        this.uvs = uvs || new Float32Array([\n            0, 0,\n            1, 0,\n            1, 1,\n            0, 1]);\n\n        /**\n         * An array of vertices\n         *\n         * @member {Float32Array}\n         */\n        this.vertices = vertices || new Float32Array([\n            0, 0,\n            100, 0,\n            100, 100,\n            0, 100]);\n\n        /**\n         * An array containing the indices of the vertices\n         *\n         * @member {Uint16Array}\n         */\n        //  TODO auto generate this based on draw mode!\n        this.indices = indices || new Uint16Array([0, 1, 3, 2]);\n\n        /**\n         * Version of mesh uvs are dirty or not\n         *\n         * @member {number}\n         */\n        this.dirty = 0;\n\n        /**\n         * Version of mesh indices\n         *\n         * @member {number}\n         */\n        this.indexDirty = 0;\n\n        /**\n         * Version of mesh verticies array\n         *\n         * @member {number}\n         */\n        this.vertexDirty = 0;\n\n        /**\n         * For backwards compatibility the default is to re-upload verticies each render call.\n         * Set this to `false` and increase `vertexDirty` to manually re-upload the buffer.\n         *\n         * @member {boolean}\n         */\n        this.autoUpdate = true;\n\n        /**\n         * The blend mode to be applied to the sprite. Set to `PIXI.BLEND_MODES.NORMAL` to remove\n         * any blend mode.\n         *\n         * @member {number}\n         * @default PIXI.BLEND_MODES.NORMAL\n         * @see PIXI.BLEND_MODES\n         */\n        this.blendMode = core.BLEND_MODES.NORMAL;\n\n        /**\n         * Triangles in canvas mode are automatically antialiased, use this value to force triangles\n         * to overlap a bit with each other.\n         *\n         * @member {number}\n         */\n        this.canvasPadding = core.settings.MESH_CANVAS_PADDING;\n\n        /**\n         * The way the Mesh should be drawn, can be any of the {@link PIXI.mesh.Mesh.DRAW_MODES} consts\n         *\n         * @member {number}\n         * @see PIXI.mesh.Mesh.DRAW_MODES\n         */\n        this.drawMode = drawMode || Mesh.DRAW_MODES.TRIANGLE_MESH;\n\n        /**\n         * The default shader that is used if a mesh doesn't have a more specific one.\n         *\n         * @member {PIXI.Shader}\n         */\n        this.shader = null;\n\n        /**\n         * The tint applied to the mesh. This is a [r,g,b] value. A value of [1,1,1] will remove any\n         * tint effect.\n         *\n         * @member {number}\n         */\n        this.tintRgb = new Float32Array([1, 1, 1]);\n\n        /**\n         * A map of renderer IDs to webgl render data\n         *\n         * @private\n         * @member {object<number, object>}\n         */\n        this._glDatas = {};\n\n        /**\n         * transform that is applied to UV to get the texture coords\n         * its updated independently from texture uvTransform\n         * updates of uvs are tied to that thing\n         *\n         * @member {PIXI.TextureMatrix}\n         * @private\n         */\n        this._uvTransform = new core.TextureMatrix(this._texture);\n\n        /**\n         * whether or not upload uvTransform to shader\n         * if its false, then uvs should be pre-multiplied\n         * if you change it for generated mesh, please call 'refresh(true)'\n         * @member {boolean}\n         * @default false\n         */\n        this.uploadUvTransform = false;\n\n        /**\n         * Plugin that is responsible for rendering this element.\n         * Allows to customize the rendering process without overriding '_renderWebGL' & '_renderCanvas' methods.\n         * @member {string}\n         * @default 'mesh'\n         */\n        this.pluginName = 'mesh';\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @private\n     * @param {PIXI.WebGLRenderer} renderer - a reference to the WebGL renderer\n     */\n    _renderWebGL(renderer)\n    {\n        this.refresh();\n        renderer.setObjectRenderer(renderer.plugins[this.pluginName]);\n        renderer.plugins[this.pluginName].render(this);\n    }\n\n    /**\n     * Renders the object using the Canvas renderer\n     *\n     * @private\n     * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.\n     */\n    _renderCanvas(renderer)\n    {\n        this.refresh();\n        renderer.plugins[this.pluginName].render(this);\n    }\n\n    /**\n     * When the texture is updated, this event will fire to update the scale and frame\n     *\n     * @private\n     */\n    _onTextureUpdate()\n    {\n        this._uvTransform.texture = this._texture;\n        this.refresh();\n    }\n\n    /**\n     * multiplies uvs only if uploadUvTransform is false\n     * call it after you change uvs manually\n     * make sure that texture is valid\n     */\n    multiplyUvs()\n    {\n        if (!this.uploadUvTransform)\n        {\n            this._uvTransform.multiplyUvs(this.uvs);\n        }\n    }\n\n    /**\n     * Refreshes uvs for generated meshes (rope, plane)\n     * sometimes refreshes vertices too\n     *\n     * @param {boolean} [forceUpdate=false] if true, matrices will be updated any case\n     */\n    refresh(forceUpdate)\n    {\n        if (this.autoUpdate)\n        {\n            this.vertexDirty++;\n        }\n        if (this._uvTransform.update(forceUpdate))\n        {\n            this._refresh();\n        }\n    }\n\n    /**\n     * re-calculates mesh coords\n     * @protected\n     */\n    _refresh()\n    {\n        /* empty */\n    }\n\n    /**\n     * Returns the bounds of the mesh as a rectangle. The bounds calculation takes the worldTransform into account.\n     *\n     */\n    _calculateBounds()\n    {\n        // TODO - we can cache local bounds and use them if they are dirty (like graphics)\n        this._bounds.addVertices(this.transform, this.vertices, 0, this.vertices.length);\n    }\n\n    /**\n     * Tests if a point is inside this mesh. Works only for TRIANGLE_MESH\n     *\n     * @param {PIXI.Point} point - the point to test\n     * @return {boolean} the result of the test\n     */\n    containsPoint(point)\n    {\n        if (!this.getBounds().contains(point.x, point.y))\n        {\n            return false;\n        }\n\n        this.worldTransform.applyInverse(point, tempPoint);\n\n        const vertices = this.vertices;\n        const points = tempPolygon.points;\n        const indices = this.indices;\n        const len = this.indices.length;\n        const step = this.drawMode === Mesh.DRAW_MODES.TRIANGLES ? 3 : 1;\n\n        for (let i = 0; i + 2 < len; i += step)\n        {\n            const ind0 = indices[i] * 2;\n            const ind1 = indices[i + 1] * 2;\n            const ind2 = indices[i + 2] * 2;\n\n            points[0] = vertices[ind0];\n            points[1] = vertices[ind0 + 1];\n            points[2] = vertices[ind1];\n            points[3] = vertices[ind1 + 1];\n            points[4] = vertices[ind2];\n            points[5] = vertices[ind2 + 1];\n\n            if (tempPolygon.contains(tempPoint.x, tempPoint.y))\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * The texture that the mesh uses.\n     *\n     * @member {PIXI.Texture}\n     */\n    get texture()\n    {\n        return this._texture;\n    }\n\n    set texture(value) // eslint-disable-line require-jsdoc\n    {\n        if (this._texture === value)\n        {\n            return;\n        }\n\n        this._texture = value;\n\n        if (value)\n        {\n            // wait for the texture to load\n            if (value.baseTexture.hasLoaded)\n            {\n                this._onTextureUpdate();\n            }\n            else\n            {\n                value.once('update', this._onTextureUpdate, this);\n            }\n        }\n    }\n\n    /**\n     * The tint applied to the mesh. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n     *\n     * @member {number}\n     * @default 0xFFFFFF\n     */\n    get tint()\n    {\n        return core.utils.rgb2hex(this.tintRgb);\n    }\n\n    set tint(value) // eslint-disable-line require-jsdoc\n    {\n        this.tintRgb = core.utils.hex2rgb(value, this.tintRgb);\n    }\n\n    /**\n     * Destroys the Mesh object.\n     *\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all\n     *  options have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have\n     *  their destroy method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the texture of the child sprite\n     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the base texture of the child sprite\n     */\n    destroy(options)\n    {\n        // for each webgl data entry, destroy the WebGLGraphicsData\n        for (const id in this._glDatas)\n        {\n            const data = this._glDatas[id];\n\n            if (data.destroy)\n            {\n                data.destroy();\n            }\n            else\n            {\n                if (data.vertexBuffer)\n                {\n                    data.vertexBuffer.destroy();\n                    data.vertexBuffer = null;\n                }\n                if (data.indexBuffer)\n                {\n                    data.indexBuffer.destroy();\n                    data.indexBuffer = null;\n                }\n                if (data.uvBuffer)\n                {\n                    data.uvBuffer.destroy();\n                    data.uvBuffer = null;\n                }\n                if (data.vao)\n                {\n                    data.vao.destroy();\n                    data.vao = null;\n                }\n            }\n        }\n\n        this._glDatas = null;\n\n        super.destroy(options);\n    }\n}\n\n/**\n * Different drawing buffer modes supported\n *\n * @static\n * @constant\n * @type {object}\n * @property {number} TRIANGLE_MESH\n * @property {number} TRIANGLES\n */\nMesh.DRAW_MODES = {\n    TRIANGLE_MESH: 0,\n    TRIANGLES: 1,\n};\n"]}