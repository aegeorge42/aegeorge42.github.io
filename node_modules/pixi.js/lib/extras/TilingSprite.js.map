{"version":3,"sources":["../../src/extras/TilingSprite.js"],"names":["core","tempPoint","Point","TilingSprite","texture","width","height","tileTransform","TransformStatic","_width","_height","_canvasPattern","uvTransform","transform","TextureMatrix","pluginName","uvRespectAnchor","_onTextureUpdate","_texture","cachedTint","_renderWebGL","renderer","valid","updateLocalTransform","update","setObjectRenderer","plugins","render","_renderCanvas","baseTexture","hasLoaded","context","worldTransform","resolution","isTextureRotated","rotate","baseTextureResolution","modX","tilePosition","x","tileScale","orig","modY","y","_textureID","_updateID","tint","tempCanvas","CanvasRenderTarget","tintedTexture","getTintedTexture","drawImage","sx","_frame","sy","sWidth","sHeight","dWidth","trim","dHeight","dx","dy","Math","PI","translate","source","createPattern","canvas","globalAlpha","worldAlpha","setTransform","a","b","c","d","tx","ty","setBlendMode","blendMode","fillStyle","scale","anchorX","anchor","anchorY","fillRect","_calculateBounds","minX","_anchor","_x","minY","_y","maxX","maxY","_bounds","addFrame","getLocalBounds","rect","children","length","_localBoundsRect","Rectangle","getRectangle","call","containsPoint","point","applyInverse","x1","y1","destroy","options","from","Texture","fromFrame","frameId","utils","TextureCache","Error","fromImage","imageId","crossorigin","scaleMode","clampMargin","value","copy","position","Sprite"],"mappings":"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","file":"TilingSprite.js","sourcesContent":["import * as core from '../core';\nimport CanvasTinter from '../core/sprites/canvas/CanvasTinter';\n\nconst tempPoint = new core.Point();\n\n/**\n * A tiling sprite is a fast way of rendering a tiling image\n *\n * @class\n * @extends PIXI.Sprite\n * @memberof PIXI.extras\n */\nexport default class TilingSprite extends core.Sprite\n{\n    /**\n     * @param {PIXI.Texture} texture - the texture of the tiling sprite\n     * @param {number} [width=100] - the width of the tiling sprite\n     * @param {number} [height=100] - the height of the tiling sprite\n     */\n    constructor(texture, width = 100, height = 100)\n    {\n        super(texture);\n\n        /**\n         * Tile transform\n         *\n         * @member {PIXI.TransformStatic}\n         */\n        this.tileTransform = new core.TransformStatic();\n\n        // /// private\n\n        /**\n         * The with of the tiling sprite\n         *\n         * @member {number}\n         * @private\n         */\n        this._width = width;\n\n        /**\n         * The height of the tiling sprite\n         *\n         * @member {number}\n         * @private\n         */\n        this._height = height;\n\n        /**\n         * Canvas pattern\n         *\n         * @type {CanvasPattern}\n         * @private\n         */\n        this._canvasPattern = null;\n\n        /**\n         * transform that is applied to UV to get the texture coords\n         *\n         * @member {PIXI.TextureMatrix}\n         */\n        this.uvTransform = texture.transform || new core.TextureMatrix(texture);\n\n        /**\n         * Plugin that is responsible for rendering this element.\n         * Allows to customize the rendering process without overriding '_renderWebGL' method.\n         *\n         * @member {string}\n         * @default 'tilingSprite'\n         */\n        this.pluginName = 'tilingSprite';\n\n        /**\n         * Whether or not anchor affects uvs\n         *\n         * @member {boolean}\n         * @default false\n         */\n        this.uvRespectAnchor = false;\n    }\n    /**\n     * Changes frame clamping in corresponding textureTransform, shortcut\n     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n     *\n     * @default 0.5\n     * @member {number}\n     */\n    get clampMargin()\n    {\n        return this.uvTransform.clampMargin;\n    }\n\n    set clampMargin(value) // eslint-disable-line require-jsdoc\n    {\n        this.uvTransform.clampMargin = value;\n        this.uvTransform.update(true);\n    }\n\n    /**\n     * The scaling of the image that is being tiled\n     *\n     * @member {PIXI.ObservablePoint}\n     */\n    get tileScale()\n    {\n        return this.tileTransform.scale;\n    }\n\n    set tileScale(value) // eslint-disable-line require-jsdoc\n    {\n        this.tileTransform.scale.copy(value);\n    }\n\n    /**\n     * The offset of the image that is being tiled\n     *\n     * @member {PIXI.ObservablePoint}\n     */\n    get tilePosition()\n    {\n        return this.tileTransform.position;\n    }\n\n    set tilePosition(value) // eslint-disable-line require-jsdoc\n    {\n        this.tileTransform.position.copy(value);\n    }\n\n    /**\n     * @private\n     */\n    _onTextureUpdate()\n    {\n        if (this.uvTransform)\n        {\n            this.uvTransform.texture = this._texture;\n        }\n        this.cachedTint = 0xFFFFFF;\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @private\n     * @param {PIXI.WebGLRenderer} renderer - The renderer\n     */\n    _renderWebGL(renderer)\n    {\n        // tweak our texture temporarily..\n        const texture = this._texture;\n\n        if (!texture || !texture.valid)\n        {\n            return;\n        }\n\n        this.tileTransform.updateLocalTransform();\n        this.uvTransform.update();\n\n        renderer.setObjectRenderer(renderer.plugins[this.pluginName]);\n        renderer.plugins[this.pluginName].render(this);\n    }\n\n    /**\n     * Renders the object using the Canvas renderer\n     *\n     * @private\n     * @param {PIXI.CanvasRenderer} renderer - a reference to the canvas renderer\n     */\n    _renderCanvas(renderer)\n    {\n        const texture = this._texture;\n\n        if (!texture.baseTexture.hasLoaded)\n        {\n            return;\n        }\n\n        const context = renderer.context;\n        const transform = this.worldTransform;\n        const resolution = renderer.resolution;\n        const isTextureRotated = texture.rotate === 2;\n        const baseTexture = texture.baseTexture;\n        const baseTextureResolution = baseTexture.resolution;\n        const modX = ((this.tilePosition.x / this.tileScale.x) % texture.orig.width) * baseTextureResolution;\n        const modY = ((this.tilePosition.y / this.tileScale.y) % texture.orig.height) * baseTextureResolution;\n\n        // create a nice shiny pattern!\n        if (this._textureID !== this._texture._updateID || this.cachedTint !== this.tint)\n        {\n            this._textureID = this._texture._updateID;\n            // cut an object from a spritesheet..\n            const tempCanvas = new core.CanvasRenderTarget(texture.orig.width,\n                                                        texture.orig.height,\n                                                        baseTextureResolution);\n\n            // Tint the tiling sprite\n            if (this.tint !== 0xFFFFFF)\n            {\n                this.tintedTexture = CanvasTinter.getTintedTexture(this, this.tint);\n                tempCanvas.context.drawImage(this.tintedTexture, 0, 0);\n            }\n            else\n            {\n                const sx = texture._frame.x * baseTextureResolution;\n                const sy = texture._frame.y * baseTextureResolution;\n                const sWidth = texture._frame.width * baseTextureResolution;\n                const sHeight = texture._frame.height * baseTextureResolution;\n                const dWidth = (texture.trim ? texture.trim.width : texture.orig.width) * baseTextureResolution;\n                const dHeight = (texture.trim ? texture.trim.height : texture.orig.height) * baseTextureResolution;\n                const dx = (texture.trim ? texture.trim.x : 0) * baseTextureResolution;\n                const dy = (texture.trim ? texture.trim.y : 0) * baseTextureResolution;\n\n                if (isTextureRotated)\n                {\n                    // Apply rotation and transform\n                    tempCanvas.context.rotate(-Math.PI / 2);\n                    tempCanvas.context.translate(-dHeight, 0);\n                    tempCanvas.context.drawImage(baseTexture.source,\n                                                sx, sy,\n                                                sWidth, sHeight,\n                                                -dy, dx,\n                                                dHeight, dWidth);\n                }\n                else\n                    {\n                    tempCanvas.context.drawImage(baseTexture.source,\n                                                sx, sy,\n                                                sWidth, sHeight,\n                                                dx, dy,\n                                                dWidth, dHeight);\n                }\n            }\n\n            this.cachedTint = this.tint;\n            this._canvasPattern = tempCanvas.context.createPattern(tempCanvas.canvas, 'repeat');\n        }\n\n        // set context state..\n        context.globalAlpha = this.worldAlpha;\n        context.setTransform(transform.a * resolution,\n                           transform.b * resolution,\n                           transform.c * resolution,\n                           transform.d * resolution,\n                           transform.tx * resolution,\n                           transform.ty * resolution);\n\n        renderer.setBlendMode(this.blendMode);\n\n        // fill the pattern!\n        context.fillStyle = this._canvasPattern;\n\n        // TODO - this should be rolled into the setTransform above..\n        context.scale(this.tileScale.x / baseTextureResolution, this.tileScale.y / baseTextureResolution);\n\n        const anchorX = this.anchor.x * -this._width * baseTextureResolution;\n        const anchorY = this.anchor.y * -this._height * baseTextureResolution;\n\n        if (this.uvRespectAnchor)\n        {\n            context.translate(modX, modY);\n\n            context.fillRect(-modX + anchorX, -modY + anchorY,\n                this._width / this.tileScale.x * baseTextureResolution,\n                this._height / this.tileScale.y * baseTextureResolution);\n        }\n        else\n        {\n            context.translate(modX + anchorX, modY + anchorY);\n\n            context.fillRect(-modX, -modY,\n                this._width / this.tileScale.x * baseTextureResolution,\n                this._height / this.tileScale.y * baseTextureResolution);\n        }\n    }\n\n    /**\n     * Updates the bounds of the tiling sprite.\n     *\n     * @private\n     */\n    _calculateBounds()\n    {\n        const minX = this._width * -this._anchor._x;\n        const minY = this._height * -this._anchor._y;\n        const maxX = this._width * (1 - this._anchor._x);\n        const maxY = this._height * (1 - this._anchor._y);\n\n        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n    }\n\n    /**\n     * Gets the local bounds of the sprite object.\n     *\n     * @param {PIXI.Rectangle} rect - The output rectangle.\n     * @return {PIXI.Rectangle} The bounds.\n     */\n    getLocalBounds(rect)\n    {\n        // we can do a fast local bounds if the sprite has no children!\n        if (this.children.length === 0)\n        {\n            this._bounds.minX = this._width * -this._anchor._x;\n            this._bounds.minY = this._height * -this._anchor._y;\n            this._bounds.maxX = this._width * (1 - this._anchor._x);\n            this._bounds.maxY = this._height * (1 - this._anchor._y);\n\n            if (!rect)\n            {\n                if (!this._localBoundsRect)\n                {\n                    this._localBoundsRect = new core.Rectangle();\n                }\n\n                rect = this._localBoundsRect;\n            }\n\n            return this._bounds.getRectangle(rect);\n        }\n\n        return super.getLocalBounds.call(this, rect);\n    }\n\n    /**\n     * Checks if a point is inside this tiling sprite.\n     *\n     * @param {PIXI.Point} point - the point to check\n     * @return {boolean} Whether or not the sprite contains the point.\n     */\n    containsPoint(point)\n    {\n        this.worldTransform.applyInverse(point, tempPoint);\n\n        const width = this._width;\n        const height = this._height;\n        const x1 = -width * this.anchor._x;\n\n        if (tempPoint.x >= x1 && tempPoint.x < x1 + width)\n        {\n            const y1 = -height * this.anchor._y;\n\n            if (tempPoint.y >= y1 && tempPoint.y < y1 + height)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Destroys this sprite and optionally its texture and children\n     *\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n     *      method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well\n     * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well\n     */\n    destroy(options)\n    {\n        super.destroy(options);\n\n        this.tileTransform = null;\n        this.uvTransform = null;\n    }\n\n    /**\n     * Helper function that creates a new tiling sprite based on the source you provide.\n     * The source can be - frame id, image url, video url, canvas element, video element, base texture\n     *\n     * @static\n     * @param {number|string|PIXI.BaseTexture|HTMLCanvasElement|HTMLVideoElement} source - Source to create texture from\n     * @param {number} width - the width of the tiling sprite\n     * @param {number} height - the height of the tiling sprite\n     * @return {PIXI.Texture} The newly created texture\n     */\n    static from(source, width, height)\n    {\n        return new TilingSprite(core.Texture.from(source), width, height);\n    }\n\n    /**\n     * Helper function that creates a tiling sprite that will use a texture from the TextureCache based on the frameId\n     * The frame ids are created when a Texture packer file has been loaded\n     *\n     * @static\n     * @param {string} frameId - The frame Id of the texture in the cache\n     * @param {number} width - the width of the tiling sprite\n     * @param {number} height - the height of the tiling sprite\n     * @return {PIXI.extras.TilingSprite} A new TilingSprite using a texture from the texture cache matching the frameId\n     */\n    static fromFrame(frameId, width, height)\n    {\n        const texture = core.utils.TextureCache[frameId];\n\n        if (!texture)\n        {\n            throw new Error(`The frameId \"${frameId}\" does not exist in the texture cache ${this}`);\n        }\n\n        return new TilingSprite(texture, width, height);\n    }\n\n    /**\n     * Helper function that creates a sprite that will contain a texture based on an image url\n     * If the image is not in the texture cache it will be loaded\n     *\n     * @static\n     * @param {string} imageId - The image url of the texture\n     * @param {number} width - the width of the tiling sprite\n     * @param {number} height - the height of the tiling sprite\n     * @param {boolean} [crossorigin] - if you want to specify the cross-origin parameter\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - if you want to specify the scale mode,\n     *  see {@link PIXI.SCALE_MODES} for possible values\n     * @return {PIXI.extras.TilingSprite} A new TilingSprite using a texture from the texture cache matching the image id\n     */\n    static fromImage(imageId, width, height, crossorigin, scaleMode)\n    {\n        return new TilingSprite(core.Texture.fromImage(imageId, crossorigin, scaleMode), width, height);\n    }\n\n    /**\n     * The width of the sprite, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n    get width()\n    {\n        return this._width;\n    }\n\n    set width(value) // eslint-disable-line require-jsdoc\n    {\n        this._width = value;\n    }\n\n    /**\n     * The height of the TilingSprite, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n    get height()\n    {\n        return this._height;\n    }\n\n    set height(value) // eslint-disable-line require-jsdoc\n    {\n        this._height = value;\n    }\n}\n"]}