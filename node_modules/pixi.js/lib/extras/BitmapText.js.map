{"version":3,"sources":["../../src/extras/BitmapText.js"],"names":["core","BitmapText","text","style","_textWidth","_textHeight","_glyphs","_font","tint","undefined","align","name","size","font","_text","_maxWidth","_maxLineHeight","_letterSpacing","_anchor","dirty","updateText","data","fonts","scale","pos","Point","chars","lineWidths","replace","textLength","length","maxWidth","prevCharCode","lastLineWidth","maxLineWidth","line","lastBreakPos","lastBreakWidth","spacesRemoved","maxLineHeight","i","charCode","charCodeAt","char","charAt","test","push","Math","max","x","y","lineHeight","charData","kerning","texture","position","xOffset","yOffset","xAdvance","height","utils","removeItems","lastChar","lineAlignOffsets","alignOffset","lenChars","c","Sprite","parent","addChild","removeChild","anchor","updateTransform","validate","containerUpdateTransform","getLocalBounds","registerFont","xml","textures","info","getElementsByTagName","common","pages","res","getAttribute","RESOLUTION","pagesTextures","parseInt","Texture","id","file","Array","letters","letter","page","textureRect","Rectangle","frame","baseTexture","kernings","first","second","amount","value","set","copy","split","slice","join","toString","Container"],"mappings":"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","file":"BitmapText.js","sourcesContent":["import * as core from '../core';\nimport ObservablePoint from '../core/math/ObservablePoint';\nimport { getResolutionOfUrl } from '../core/utils';\nimport settings from '../core/settings';\n\n/**\n * A BitmapText object will create a line or multiple lines of text using bitmap font. To\n * split a line you can use '\\n', '\\r' or '\\r\\n' in your string. You can generate the fnt files using:\n *\n * A BitmapText can only be created when the font is loaded\n *\n * ```js\n * // in this case the font is in a file called 'desyrel.fnt'\n * let bitmapText = new PIXI.extras.BitmapText(\"text using a fancy font!\", {font: \"35px Desyrel\", align: \"right\"});\n * ```\n *\n * http://www.angelcode.com/products/bmfont/ for windows or\n * http://www.bmglyph.com/ for mac.\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI.extras\n */\nexport default class BitmapText extends core.Container\n{\n    /**\n     * @param {string} text - The copy that you would like the text to display\n     * @param {object} style - The style parameters\n     * @param {string|object} style.font - The font descriptor for the object, can be passed as a string of form\n     *      \"24px FontName\" or \"FontName\" or as an object with explicit name/size properties.\n     * @param {string} [style.font.name] - The bitmap font id\n     * @param {number} [style.font.size] - The size of the font in pixels, e.g. 24\n     * @param {string} [style.align='left'] - Alignment for multiline text ('left', 'center' or 'right'), does not affect\n     *      single line text\n     * @param {number} [style.tint=0xFFFFFF] - The tint color\n     */\n    constructor(text, style = {})\n    {\n        super();\n\n        /**\n         * Private tracker for the width of the overall text\n         *\n         * @member {number}\n         * @private\n         */\n        this._textWidth = 0;\n\n        /**\n         * Private tracker for the height of the overall text\n         *\n         * @member {number}\n         * @private\n         */\n        this._textHeight = 0;\n\n        /**\n         * Private tracker for the letter sprite pool.\n         *\n         * @member {PIXI.Sprite[]}\n         * @private\n         */\n        this._glyphs = [];\n\n        /**\n         * Private tracker for the current style.\n         *\n         * @member {object}\n         * @private\n         */\n        this._font = {\n            tint: style.tint !== undefined ? style.tint : 0xFFFFFF,\n            align: style.align || 'left',\n            name: null,\n            size: 0,\n        };\n\n        /**\n         * Private tracker for the current font.\n         *\n         * @member {object}\n         * @private\n         */\n        this.font = style.font; // run font setter\n\n        /**\n         * Private tracker for the current text.\n         *\n         * @member {string}\n         * @private\n         */\n        this._text = text;\n\n        /**\n         * The max width of this bitmap text in pixels. If the text provided is longer than the\n         * value provided, line breaks will be automatically inserted in the last whitespace.\n         * Disable by setting value to 0\n         *\n         * @member {number}\n         * @private\n         */\n        this._maxWidth = 0;\n\n        /**\n         * The max line height. This is useful when trying to use the total height of the Text,\n         * ie: when trying to vertically align.\n         *\n         * @member {number}\n         * @private\n         */\n        this._maxLineHeight = 0;\n\n        /**\n         * Letter spacing. This is useful for setting the space between characters.\n         * @member {number}\n         * @private\n         */\n        this._letterSpacing = 0;\n\n        /**\n         * Text anchor. read-only\n         *\n         * @member {PIXI.ObservablePoint}\n         * @private\n         */\n        this._anchor = new ObservablePoint(() => { this.dirty = true; }, this, 0, 0);\n\n        /**\n         * The dirty state of this object.\n         *\n         * @member {boolean}\n         */\n        this.dirty = false;\n\n        this.updateText();\n    }\n\n    /**\n     * Renders text and updates it when needed\n     *\n     * @private\n     */\n    updateText()\n    {\n        const data = BitmapText.fonts[this._font.name];\n        const scale = this._font.size / data.size;\n        const pos = new core.Point();\n        const chars = [];\n        const lineWidths = [];\n        const text = this.text.replace(/(?:\\r\\n|\\r)/g, '\\n');\n        const textLength = text.length;\n        const maxWidth = this._maxWidth * data.size / this._font.size;\n\n        let prevCharCode = null;\n        let lastLineWidth = 0;\n        let maxLineWidth = 0;\n        let line = 0;\n        let lastBreakPos = -1;\n        let lastBreakWidth = 0;\n        let spacesRemoved = 0;\n        let maxLineHeight = 0;\n\n        for (let i = 0; i < textLength; i++)\n        {\n            const charCode = text.charCodeAt(i);\n            const char = text.charAt(i);\n\n            if (/(?:\\s)/.test(char))\n            {\n                lastBreakPos = i;\n                lastBreakWidth = lastLineWidth;\n            }\n\n            if (char === '\\r' || char === '\\n')\n            {\n                lineWidths.push(lastLineWidth);\n                maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n                ++line;\n                ++spacesRemoved;\n\n                pos.x = 0;\n                pos.y += data.lineHeight;\n                prevCharCode = null;\n                continue;\n            }\n\n            const charData = data.chars[charCode];\n\n            if (!charData)\n            {\n                continue;\n            }\n\n            if (prevCharCode && charData.kerning[prevCharCode])\n            {\n                pos.x += charData.kerning[prevCharCode];\n            }\n\n            chars.push({\n                texture: charData.texture,\n                line,\n                charCode,\n                position: new core.Point(pos.x + charData.xOffset + (this._letterSpacing / 2), pos.y + charData.yOffset),\n            });\n            pos.x += charData.xAdvance + this._letterSpacing;\n            lastLineWidth = pos.x;\n            maxLineHeight = Math.max(maxLineHeight, (charData.yOffset + charData.texture.height));\n            prevCharCode = charCode;\n\n            if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth)\n            {\n                ++spacesRemoved;\n                core.utils.removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos);\n                i = lastBreakPos;\n                lastBreakPos = -1;\n\n                lineWidths.push(lastBreakWidth);\n                maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);\n                line++;\n\n                pos.x = 0;\n                pos.y += data.lineHeight;\n                prevCharCode = null;\n            }\n        }\n\n        const lastChar = text.charAt(text.length - 1);\n\n        if (lastChar !== '\\r' && lastChar !== '\\n')\n        {\n            if (/(?:\\s)/.test(lastChar))\n            {\n                lastLineWidth = lastBreakWidth;\n            }\n\n            lineWidths.push(lastLineWidth);\n            maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n        }\n\n        const lineAlignOffsets = [];\n\n        for (let i = 0; i <= line; i++)\n        {\n            let alignOffset = 0;\n\n            if (this._font.align === 'right')\n            {\n                alignOffset = maxLineWidth - lineWidths[i];\n            }\n            else if (this._font.align === 'center')\n            {\n                alignOffset = (maxLineWidth - lineWidths[i]) / 2;\n            }\n\n            lineAlignOffsets.push(alignOffset);\n        }\n\n        const lenChars = chars.length;\n        const tint = this.tint;\n\n        for (let i = 0; i < lenChars; i++)\n        {\n            let c = this._glyphs[i]; // get the next glyph sprite\n\n            if (c)\n            {\n                c.texture = chars[i].texture;\n            }\n            else\n            {\n                c = new core.Sprite(chars[i].texture);\n                this._glyphs.push(c);\n            }\n\n            c.position.x = (chars[i].position.x + lineAlignOffsets[chars[i].line]) * scale;\n            c.position.y = chars[i].position.y * scale;\n            c.scale.x = c.scale.y = scale;\n            c.tint = tint;\n\n            if (!c.parent)\n            {\n                this.addChild(c);\n            }\n        }\n\n        // remove unnecessary children.\n        for (let i = lenChars; i < this._glyphs.length; ++i)\n        {\n            this.removeChild(this._glyphs[i]);\n        }\n\n        this._textWidth = maxLineWidth * scale;\n        this._textHeight = (pos.y + data.lineHeight) * scale;\n\n        // apply anchor\n        if (this.anchor.x !== 0 || this.anchor.y !== 0)\n        {\n            for (let i = 0; i < lenChars; i++)\n            {\n                this._glyphs[i].x -= this._textWidth * this.anchor.x;\n                this._glyphs[i].y -= this._textHeight * this.anchor.y;\n            }\n        }\n        this._maxLineHeight = maxLineHeight * scale;\n    }\n\n    /**\n     * Updates the transform of this object\n     *\n     * @private\n     */\n    updateTransform()\n    {\n        this.validate();\n        this.containerUpdateTransform();\n    }\n\n    /**\n     * Validates text before calling parent's getLocalBounds\n     *\n     * @return {PIXI.Rectangle} The rectangular bounding area\n     */\n    getLocalBounds()\n    {\n        this.validate();\n\n        return super.getLocalBounds();\n    }\n\n    /**\n     * Updates text when needed\n     *\n     * @private\n     */\n    validate()\n    {\n        if (this.dirty)\n        {\n            this.updateText();\n            this.dirty = false;\n        }\n    }\n\n    /**\n     * The tint of the BitmapText object\n     *\n     * @member {number}\n     */\n    get tint()\n    {\n        return this._font.tint;\n    }\n\n    set tint(value) // eslint-disable-line require-jsdoc\n    {\n        this._font.tint = (typeof value === 'number' && value >= 0) ? value : 0xFFFFFF;\n\n        this.dirty = true;\n    }\n\n    /**\n     * The alignment of the BitmapText object\n     *\n     * @member {string}\n     * @default 'left'\n     */\n    get align()\n    {\n        return this._font.align;\n    }\n\n    set align(value) // eslint-disable-line require-jsdoc\n    {\n        this._font.align = value || 'left';\n\n        this.dirty = true;\n    }\n\n    /**\n     * The anchor sets the origin point of the text.\n     * The default is 0,0 this means the text's origin is the top left\n     * Setting the anchor to 0.5,0.5 means the text's origin is centered\n     * Setting the anchor to 1,1 would mean the text's origin point will be the bottom right corner\n     *\n     * @member {PIXI.Point | number}\n     */\n    get anchor()\n    {\n        return this._anchor;\n    }\n\n    set anchor(value) // eslint-disable-line require-jsdoc\n    {\n        if (typeof value === 'number')\n        {\n            this._anchor.set(value);\n        }\n        else\n        {\n            this._anchor.copy(value);\n        }\n    }\n\n    /**\n     * The font descriptor of the BitmapText object\n     *\n     * @member {string|object}\n     */\n    get font()\n    {\n        return this._font;\n    }\n\n    set font(value) // eslint-disable-line require-jsdoc\n    {\n        if (!value)\n        {\n            return;\n        }\n\n        if (typeof value === 'string')\n        {\n            value = value.split(' ');\n\n            this._font.name = value.length === 1 ? value[0] : value.slice(1).join(' ');\n            this._font.size = value.length >= 2 ? parseInt(value[0], 10) : BitmapText.fonts[this._font.name].size;\n        }\n        else\n        {\n            this._font.name = value.name;\n            this._font.size = typeof value.size === 'number' ? value.size : parseInt(value.size, 10);\n        }\n\n        this.dirty = true;\n    }\n\n    /**\n     * The text of the BitmapText object\n     *\n     * @member {string}\n     */\n    get text()\n    {\n        return this._text;\n    }\n\n    set text(value) // eslint-disable-line require-jsdoc\n    {\n        value = value.toString() || ' ';\n        if (this._text === value)\n        {\n            return;\n        }\n        this._text = value;\n        this.dirty = true;\n    }\n\n    /**\n     * The max width of this bitmap text in pixels. If the text provided is longer than the\n     * value provided, line breaks will be automatically inserted in the last whitespace.\n     * Disable by setting value to 0\n     *\n     * @member {number}\n     */\n    get maxWidth()\n    {\n        return this._maxWidth;\n    }\n\n    set maxWidth(value) // eslint-disable-line require-jsdoc\n    {\n        if (this._maxWidth === value)\n        {\n            return;\n        }\n        this._maxWidth = value;\n        this.dirty = true;\n    }\n\n    /**\n     * The max line height. This is useful when trying to use the total height of the Text,\n     * ie: when trying to vertically align.\n     *\n     * @member {number}\n     * @readonly\n     */\n    get maxLineHeight()\n    {\n        this.validate();\n\n        return this._maxLineHeight;\n    }\n\n    /**\n     * The width of the overall text, different from fontSize,\n     * which is defined in the style object\n     *\n     * @member {number}\n     * @readonly\n     */\n    get textWidth()\n    {\n        this.validate();\n\n        return this._textWidth;\n    }\n\n    /**\n     * Additional space between characters.\n     *\n     * @member {number}\n     */\n    get letterSpacing()\n    {\n        return this._letterSpacing;\n    }\n\n    set letterSpacing(value) // eslint-disable-line require-jsdoc\n    {\n        if (this._letterSpacing !== value)\n        {\n            this._letterSpacing = value;\n            this.dirty = true;\n        }\n    }\n\n    /**\n     * The height of the overall text, different from fontSize,\n     * which is defined in the style object\n     *\n     * @member {number}\n     * @readonly\n     */\n    get textHeight()\n    {\n        this.validate();\n\n        return this._textHeight;\n    }\n\n    /**\n     * Register a bitmap font with data and a texture.\n     *\n     * @static\n     * @param {XMLDocument} xml - The XML document data.\n     * @param {Object.<string, PIXI.Texture>|PIXI.Texture|PIXI.Texture[]} textures - List of textures for each page.\n     *  If providing an object, the key is the `<page>` element's `file` attribute in the FNT file.\n     * @return {Object} Result font object with font, size, lineHeight and char fields.\n     */\n    static registerFont(xml, textures)\n    {\n        const data = {};\n        const info = xml.getElementsByTagName('info')[0];\n        const common = xml.getElementsByTagName('common')[0];\n        const pages = xml.getElementsByTagName('page');\n        const res = getResolutionOfUrl(pages[0].getAttribute('file'), settings.RESOLUTION);\n        const pagesTextures = {};\n\n        data.font = info.getAttribute('face');\n        data.size = parseInt(info.getAttribute('size'), 10);\n        data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10) / res;\n        data.chars = {};\n\n        // Single texture, convert to list\n        if (textures instanceof core.Texture)\n        {\n            textures = [textures];\n        }\n\n        // Convert the input Texture, Textures or object\n        // into a page Texture lookup by \"id\"\n        for (let i = 0; i < pages.length; i++)\n        {\n            const id = pages[i].getAttribute('id');\n            const file = pages[i].getAttribute('file');\n\n            pagesTextures[id] = textures instanceof Array ? textures[i] : textures[file];\n        }\n\n        // parse letters\n        const letters = xml.getElementsByTagName('char');\n\n        for (let i = 0; i < letters.length; i++)\n        {\n            const letter = letters[i];\n            const charCode = parseInt(letter.getAttribute('id'), 10);\n            const page = letter.getAttribute('page') || 0;\n            const textureRect = new core.Rectangle(\n                (parseInt(letter.getAttribute('x'), 10) / res) + (pagesTextures[page].frame.x / res),\n                (parseInt(letter.getAttribute('y'), 10) / res) + (pagesTextures[page].frame.y / res),\n                parseInt(letter.getAttribute('width'), 10) / res,\n                parseInt(letter.getAttribute('height'), 10) / res\n            );\n\n            data.chars[charCode] = {\n                xOffset: parseInt(letter.getAttribute('xoffset'), 10) / res,\n                yOffset: parseInt(letter.getAttribute('yoffset'), 10) / res,\n                xAdvance: parseInt(letter.getAttribute('xadvance'), 10) / res,\n                kerning: {},\n                texture: new core.Texture(pagesTextures[page].baseTexture, textureRect),\n                page,\n            };\n        }\n\n        // parse kernings\n        const kernings = xml.getElementsByTagName('kerning');\n\n        for (let i = 0; i < kernings.length; i++)\n        {\n            const kerning = kernings[i];\n            const first = parseInt(kerning.getAttribute('first'), 10) / res;\n            const second = parseInt(kerning.getAttribute('second'), 10) / res;\n            const amount = parseInt(kerning.getAttribute('amount'), 10) / res;\n\n            if (data.chars[second])\n            {\n                data.chars[second].kerning[first] = amount;\n            }\n        }\n\n        // I'm leaving this as a temporary fix so we can test the bitmap fonts in v3\n        // but it's very likely to change\n        BitmapText.fonts[data.font] = data;\n\n        return data;\n    }\n}\n\nBitmapText.fonts = {};\n"]}