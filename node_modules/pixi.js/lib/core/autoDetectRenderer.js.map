{"version":3,"sources":["../../src/core/autoDetectRenderer.js"],"names":["autoDetectRenderer","utils","options","arg1","arg2","arg3","forceCanvas","undefined","isWebGLSupported"],"mappings":";;;QAoCgBA,kB,GAAAA,kB;;AApChB;;IAAYC,K;;AACZ;;;;AACA;;;;;;;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BO,SAASD,kBAAT,CAA4BE,OAA5B,EAAqCC,IAArC,EAA2CC,IAA3C,EAAiDC,IAAjD,EACP;AACI;AACA,QAAIC,cAAcJ,WAAWA,QAAQI,WAArC;;AAEA,QAAID,SAASE,SAAb,EACA;AACID,sBAAcD,IAAd;AACH;;AAED,QAAI,CAACC,WAAD,IAAgBL,MAAMO,gBAAN,EAApB,EACA;AACI,eAAO,4BAAkBN,OAAlB,EAA2BC,IAA3B,EAAiCC,IAAjC,CAAP;AACH;;AAED,WAAO,6BAAmBF,OAAnB,EAA4BC,IAA5B,EAAkCC,IAAlC,CAAP;AACH","file":"autoDetectRenderer.js","sourcesContent":["import * as utils from './utils';\nimport CanvasRenderer from './renderers/canvas/CanvasRenderer';\nimport WebGLRenderer from './renderers/webgl/WebGLRenderer';\n\n// eslint-disable-next-line valid-jsdoc\n/**\n * This helper function will automatically detect which renderer you should be using.\n * WebGL is the preferred renderer as it is a lot faster. If webGL is not supported by\n * the browser then this function will return a canvas renderer\n *\n * @memberof PIXI\n * @function autoDetectRenderer\n * @param {object} [options] - The optional renderer parameters\n * @param {number} [options.width=800] - the width of the renderers view\n * @param {number} [options.height=600] - the height of the renderers view\n * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional\n * @param {boolean} [options.transparent=false] - If the render view is transparent, default false\n * @param {boolean} [options.antialias=false] - sets antialias (only applicable in chrome at the moment)\n * @param {boolean} [options.preserveDrawingBuffer=false] - enables drawing buffer preservation, enable this if you\n *  need to call toDataUrl on the webgl context\n * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area\n *  (shown if not transparent).\n * @param {boolean} [options.clearBeforeRender=true] - This sets if the renderer will clear the canvas or\n *   not before the new render pass.\n * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer, retina would be 2\n * @param {boolean} [options.forceCanvas=false] - prevents selection of WebGL renderer, even if such is present\n * @param {boolean} [options.roundPixels=false] - If true PixiJS will Math.floor() x/y values when rendering,\n *  stopping pixel interpolation.\n * @param {boolean} [options.forceFXAA=false] - forces FXAA antialiasing to be used over native.\n *  FXAA is faster, but may not always look as great **webgl only**\n * @param {boolean} [options.legacy=false] - `true` to ensure compatibility with older / less advanced devices.\n *  If you experience unexplained flickering try setting this to true. **webgl only**\n * @param {string} [options.powerPreference] - Parameter passed to webgl context, set to \"high-performance\"\n *  for devices with dual graphics card **webgl only**\n * @return {PIXI.WebGLRenderer|PIXI.CanvasRenderer} Returns WebGL renderer if available, otherwise CanvasRenderer\n */\nexport function autoDetectRenderer(options, arg1, arg2, arg3)\n{\n    // Backward-compatible support for noWebGL option\n    let forceCanvas = options && options.forceCanvas;\n\n    if (arg3 !== undefined)\n    {\n        forceCanvas = arg3;\n    }\n\n    if (!forceCanvas && utils.isWebGLSupported())\n    {\n        return new WebGLRenderer(options, arg1, arg2);\n    }\n\n    return new CanvasRenderer(options, arg1, arg2);\n}\n"]}