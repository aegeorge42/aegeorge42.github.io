{"version":3,"sources":["../../../../../src/core/graphics/webgl/utils/buildComplexPoly.js"],"names":["buildComplexPoly","graphicsData","webGLData","points","slice","length","indices","alpha","fillAlpha","color","fillColor","minX","Infinity","maxX","minY","maxY","x","y","i","push"],"mappings":";;;kBAYwBA,gB;;AAZxB;;AAEA;;;;;;;;;;AAUe,SAASA,gBAAT,CAA0BC,YAA1B,EAAwCC,SAAxC,EACf;AACI;AACA,QAAMC,SAASF,aAAaE,MAAb,CAAoBC,KAApB,EAAf;;AAEA,QAAID,OAAOE,MAAP,GAAgB,CAApB,EACA;AACI;AACH;;AAED;AACA,QAAMC,UAAUJ,UAAUI,OAA1B;;AAEAJ,cAAUC,MAAV,GAAmBA,MAAnB;AACAD,cAAUK,KAAV,GAAkBN,aAAaO,SAA/B;AACAN,cAAUO,KAAV,GAAkB,oBAAQR,aAAaS,SAArB,CAAlB;;AAEA;AACA,QAAIC,OAAOC,QAAX;AACA,QAAIC,OAAO,CAACD,QAAZ;;AAEA,QAAIE,OAAOF,QAAX;AACA,QAAIG,OAAO,CAACH,QAAZ;;AAEA,QAAII,IAAI,CAAR;AACA,QAAIC,IAAI,CAAR;;AAEA;AACA,SAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIf,OAAOE,MAA3B,EAAmCa,KAAK,CAAxC,EACA;AACIF,YAAIb,OAAOe,CAAP,CAAJ;AACAD,YAAId,OAAOe,IAAI,CAAX,CAAJ;;AAEAP,eAAOK,IAAIL,IAAJ,GAAWK,CAAX,GAAeL,IAAtB;AACAE,eAAOG,IAAIH,IAAJ,GAAWG,CAAX,GAAeH,IAAtB;;AAEAC,eAAOG,IAAIH,IAAJ,GAAWG,CAAX,GAAeH,IAAtB;AACAC,eAAOE,IAAIF,IAAJ,GAAWE,CAAX,GAAeF,IAAtB;AACH;;AAED;AACAZ,WAAOgB,IAAP,CAAYR,IAAZ,EAAkBG,IAAlB,EACYD,IADZ,EACkBC,IADlB,EAEYD,IAFZ,EAEkBE,IAFlB,EAGYJ,IAHZ,EAGkBI,IAHlB;;AAKA;;AAEA;AACA,QAAMV,SAASF,OAAOE,MAAP,GAAgB,CAA/B;;AAEA,SAAK,IAAIa,KAAI,CAAb,EAAgBA,KAAIb,MAApB,EAA4Ba,IAA5B,EACA;AACIZ,gBAAQa,IAAR,CAAaD,EAAb;AACH;AACJ","file":"buildComplexPoly.js","sourcesContent":["import { hex2rgb } from '../../../utils';\n\n/**\n * Builds a complex polygon to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.Graphics} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the webGL-specific information to create this shape\n */\nexport default function buildComplexPoly(graphicsData, webGLData)\n{\n    // TODO - no need to copy this as it gets turned into a Float32Array anyways..\n    const points = graphicsData.points.slice();\n\n    if (points.length < 6)\n    {\n        return;\n    }\n\n    // get first and last point.. figure out the middle!\n    const indices = webGLData.indices;\n\n    webGLData.points = points;\n    webGLData.alpha = graphicsData.fillAlpha;\n    webGLData.color = hex2rgb(graphicsData.fillColor);\n\n    // calculate the bounds..\n    let minX = Infinity;\n    let maxX = -Infinity;\n\n    let minY = Infinity;\n    let maxY = -Infinity;\n\n    let x = 0;\n    let y = 0;\n\n    // get size..\n    for (let i = 0; i < points.length; i += 2)\n    {\n        x = points[i];\n        y = points[i + 1];\n\n        minX = x < minX ? x : minX;\n        maxX = x > maxX ? x : maxX;\n\n        minY = y < minY ? y : minY;\n        maxY = y > maxY ? y : maxY;\n    }\n\n    // add a quad to the end cos there is no point making another buffer!\n    points.push(minX, minY,\n                maxX, minY,\n                maxX, maxY,\n                minX, maxY);\n\n    // push a quad onto the end..\n\n    // TODO - this aint needed!\n    const length = points.length / 2;\n\n    for (let i = 0; i < length; i++)\n    {\n        indices.push(i);\n    }\n}\n"]}