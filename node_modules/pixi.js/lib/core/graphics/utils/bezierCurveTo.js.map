{"version":3,"sources":["../../../../src/core/graphics/utils/bezierCurveTo.js"],"names":["bezierCurveTo","fromX","fromY","cpX","cpY","cpX2","cpY2","toX","toY","n","path","dt","dt2","dt3","t2","t3","push","i","j"],"mappings":";;;kBAkBwBA,a;AAlBxB;;;;;;;;;;;;;;;;;;AAkBe,SAASA,aAAT,CAAuBC,KAAvB,EAA8BC,KAA9B,EAAqCC,GAArC,EAA0CC,GAA1C,EAA+CC,IAA/C,EAAqDC,IAArD,EAA2DC,GAA3D,EAAgEC,GAAhE,EAAqEC,CAArE,EACf;AAAA,QADuFC,IACvF,uEAD8F,EAC9F;;AACI,QAAIC,KAAK,CAAT;AACA,QAAIC,MAAM,CAAV;AACA,QAAIC,MAAM,CAAV;AACA,QAAIC,KAAK,CAAT;AACA,QAAIC,KAAK,CAAT;;AAEAL,SAAKM,IAAL,CAAUf,KAAV,EAAiBC,KAAjB;;AAEA,SAAK,IAAIe,IAAI,CAAR,EAAWC,IAAI,CAApB,EAAuBD,KAAKR,CAA5B,EAA+B,EAAEQ,CAAjC,EACA;AACIC,YAAID,IAAIR,CAAR;;AAEAE,aAAM,IAAIO,CAAV;AACAN,cAAMD,KAAKA,EAAX;AACAE,cAAMD,MAAMD,EAAZ;;AAEAG,aAAKI,IAAIA,CAAT;AACAH,aAAKD,KAAKI,CAAV;;AAEAR,aAAKM,IAAL,CACKH,MAAMZ,KAAP,GAAiB,IAAIW,GAAJ,GAAUM,CAAV,GAAcf,GAA/B,GAAuC,IAAIQ,EAAJ,GAASG,EAAT,GAAcT,IAArD,GAA8DU,KAAKR,GADvE,EAEKM,MAAMX,KAAP,GAAiB,IAAIU,GAAJ,GAAUM,CAAV,GAAcd,GAA/B,GAAuC,IAAIO,EAAJ,GAASG,EAAT,GAAcR,IAArD,GAA8DS,KAAKP,GAFvE;AAIH;;AAED,WAAOE,IAAP;AACH","file":"bezierCurveTo.js","sourcesContent":["/**\n * Calculate the points for a bezier curve and then draws it.\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @param {number} fromX - Starting point x\n * @param {number} fromY - Starting point y\n * @param {number} cpX - Control point x\n * @param {number} cpY - Control point y\n * @param {number} cpX2 - Second Control point x\n * @param {number} cpY2 - Second Control point y\n * @param {number} toX - Destination point x\n * @param {number} toY - Destination point y\n * @param {number} n - Number of segments approximating the bezier curve\n * @param {number[]} [path=[]] - Path array to push points into\n * @return {number[]} Array of points of the curve\n */\nexport default function bezierCurveTo(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY, n, path = [])\n{\n    let dt = 0;\n    let dt2 = 0;\n    let dt3 = 0;\n    let t2 = 0;\n    let t3 = 0;\n\n    path.push(fromX, fromY);\n\n    for (let i = 1, j = 0; i <= n; ++i)\n    {\n        j = i / n;\n\n        dt = (1 - j);\n        dt2 = dt * dt;\n        dt3 = dt2 * dt;\n\n        t2 = j * j;\n        t3 = t2 * j;\n\n        path.push(\n            (dt3 * fromX) + (3 * dt2 * j * cpX) + (3 * dt * t2 * cpX2) + (t3 * toX),\n            (dt3 * fromY) + (3 * dt2 * j * cpY) + (3 * dt * t2 * cpY2) + (t3 * toY)\n        );\n    }\n\n    return path;\n}\n"]}