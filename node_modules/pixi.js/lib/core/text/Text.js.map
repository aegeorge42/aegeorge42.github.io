{"version":3,"sources":["../../../src/core/text/Text.js"],"names":["defaultDestroyOptions","texture","children","baseTexture","Text","text","style","canvas","document","createElement","width","height","fromCanvas","SCALE_MODE","orig","trim","addToCache","_texture","textureCacheIds","context","getContext","resolution","RESOLUTION","_text","_style","_styleListener","_font","localStyleID","updateText","respectDirty","styleID","dirty","toFontString","measured","measureText","wordWrap","lines","lineHeight","lineWidths","maxLineWidth","fontProperties","Math","ceil","max","padding","scale","clearRect","font","strokeStyle","stroke","lineWidth","strokeThickness","textBaseline","lineJoin","miterLimit","linePositionX","linePositionY","dropShadow","fillStyle","dropShadowColor","globalAlpha","dropShadowAlpha","shadowBlur","dropShadowBlur","shadowColor","xShadowOffset","cos","dropShadowAngle","dropShadowDistance","yShadowOffset","sin","i","length","ascent","align","fill","drawLetterSpacing","_generateFillStyle","updateTexture","x","y","isStroke","letterSpacing","strokeText","fillText","characters","String","prototype","split","call","currentPosition","index","current","previousWidth","currentWidth","substring","trimmed","data","putImageData","hasLoaded","realWidth","realHeight","_frame","_onTextureUpdate","emit","renderWebGL","renderer","_renderCanvas","getLocalBounds","rect","_calculateBounds","calculateVertices","_bounds","addQuad","vertexData","_onStyleChange","Array","isArray","navigator","isCocoonJS","gradient","totalIterations","currentIteration","stop","slice","fillGradientStops","lengthPlus1","push","unshift","fillGradientType","LINEAR_VERTICAL","createLinearGradient","j","addColorStop","destroy","options","Object","assign","abs","value","s","_width","_height","undefined"],"mappings":"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","file":"Text.js","sourcesContent":["/* eslint max-depth: [2, 8] */\nimport Sprite from '../sprites/Sprite';\nimport Texture from '../textures/Texture';\nimport { Rectangle } from '../math';\nimport { sign } from '../utils';\nimport { TEXT_GRADIENT } from '../const';\nimport settings from '../settings';\nimport TextStyle from './TextStyle';\nimport TextMetrics from './TextMetrics';\nimport trimCanvas from '../utils/trimCanvas';\n\nconst defaultDestroyOptions = {\n    texture: true,\n    children: false,\n    baseTexture: true,\n};\n\n/**\n * A Text Object will create a line or multiple lines of text. To split a line you can use '\\n' in your text string,\n * or add a wordWrap property set to true and and wordWrapWidth property with a value in the style object.\n *\n * A Text can be created directly from a string and a style object,\n * which can be generated [here](https://pixijs.io/pixi-text-style).\n *\n * ```js\n * let text = new PIXI.Text('This is a PixiJS text',{fontFamily : 'Arial', fontSize: 24, fill : 0xff1010, align : 'center'});\n * ```\n *\n * @class\n * @extends PIXI.Sprite\n * @memberof PIXI\n */\nexport default class Text extends Sprite\n{\n    /**\n     * @param {string} text - The string that you would like the text to display\n     * @param {object|PIXI.TextStyle} [style] - The style parameters\n     * @param {HTMLCanvasElement} [canvas] - The canvas element for drawing text\n     */\n    constructor(text, style, canvas)\n    {\n        canvas = canvas || document.createElement('canvas');\n\n        canvas.width = 3;\n        canvas.height = 3;\n\n        const texture = Texture.fromCanvas(canvas, settings.SCALE_MODE, 'text');\n\n        texture.orig = new Rectangle();\n        texture.trim = new Rectangle();\n\n        super(texture);\n\n        // base texture is already automatically added to the cache, now adding the actual texture\n        Texture.addToCache(this._texture, this._texture.baseTexture.textureCacheIds[0]);\n\n        /**\n         * The canvas element that everything is drawn to\n         *\n         * @member {HTMLCanvasElement}\n         */\n        this.canvas = canvas;\n\n        /**\n         * The canvas 2d context that everything is drawn with\n         * @member {CanvasRenderingContext2D}\n         */\n        this.context = this.canvas.getContext('2d');\n\n        /**\n         * The resolution / device pixel ratio of the canvas. This is set automatically by the renderer.\n         * @member {number}\n         * @default 1\n         */\n        this.resolution = settings.RESOLUTION;\n\n        /**\n         * Private tracker for the current text.\n         *\n         * @member {string}\n         * @private\n         */\n        this._text = null;\n\n        /**\n         * Private tracker for the current style.\n         *\n         * @member {object}\n         * @private\n         */\n        this._style = null;\n        /**\n         * Private listener to track style changes.\n         *\n         * @member {Function}\n         * @private\n         */\n        this._styleListener = null;\n\n        /**\n         * Private tracker for the current font.\n         *\n         * @member {string}\n         * @private\n         */\n        this._font = '';\n\n        this.text = text;\n        this.style = style;\n\n        this.localStyleID = -1;\n    }\n\n    /**\n     * Renders text and updates it when needed.\n     *\n     * @private\n     * @param {boolean} respectDirty - Whether to abort updating the text if the Text isn't dirty and the function is called.\n     */\n    updateText(respectDirty)\n    {\n        const style = this._style;\n\n        // check if style has changed..\n        if (this.localStyleID !== style.styleID)\n        {\n            this.dirty = true;\n            this.localStyleID = style.styleID;\n        }\n\n        if (!this.dirty && respectDirty)\n        {\n            return;\n        }\n\n        this._font = this._style.toFontString();\n\n        const context = this.context;\n        const measured = TextMetrics.measureText(this._text, this._style, this._style.wordWrap, this.canvas);\n        const width = measured.width;\n        const height = measured.height;\n        const lines = measured.lines;\n        const lineHeight = measured.lineHeight;\n        const lineWidths = measured.lineWidths;\n        const maxLineWidth = measured.maxLineWidth;\n        const fontProperties = measured.fontProperties;\n\n        this.canvas.width = Math.ceil((Math.max(1, width) + (style.padding * 2)) * this.resolution);\n        this.canvas.height = Math.ceil((Math.max(1, height) + (style.padding * 2)) * this.resolution);\n\n        context.scale(this.resolution, this.resolution);\n\n        context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n        context.font = this._font;\n        context.strokeStyle = style.stroke;\n        context.lineWidth = style.strokeThickness;\n        context.textBaseline = style.textBaseline;\n        context.lineJoin = style.lineJoin;\n        context.miterLimit = style.miterLimit;\n\n        let linePositionX;\n        let linePositionY;\n\n        if (style.dropShadow)\n        {\n            context.fillStyle = style.dropShadowColor;\n            context.globalAlpha = style.dropShadowAlpha;\n            context.shadowBlur = style.dropShadowBlur;\n\n            if (style.dropShadowBlur > 0)\n            {\n                context.shadowColor = style.dropShadowColor;\n            }\n\n            const xShadowOffset = Math.cos(style.dropShadowAngle) * style.dropShadowDistance;\n            const yShadowOffset = Math.sin(style.dropShadowAngle) * style.dropShadowDistance;\n\n            for (let i = 0; i < lines.length; i++)\n            {\n                linePositionX = style.strokeThickness / 2;\n                linePositionY = ((style.strokeThickness / 2) + (i * lineHeight)) + fontProperties.ascent;\n\n                if (style.align === 'right')\n                {\n                    linePositionX += maxLineWidth - lineWidths[i];\n                }\n                else if (style.align === 'center')\n                {\n                    linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n                }\n\n                if (style.fill)\n                {\n                    this.drawLetterSpacing(\n                        lines[i],\n                        linePositionX + xShadowOffset + style.padding, linePositionY + yShadowOffset + style.padding\n                    );\n\n                    if (style.stroke && style.strokeThickness)\n                    {\n                        context.strokeStyle = style.dropShadowColor;\n                        this.drawLetterSpacing(\n                            lines[i],\n                            linePositionX + xShadowOffset + style.padding, linePositionY + yShadowOffset + style.padding,\n                            true\n                        );\n                        context.strokeStyle = style.stroke;\n                    }\n                }\n            }\n        }\n\n        // reset the shadow blur and alpha that was set by the drop shadow, for the regular text\n        context.shadowBlur = 0;\n        context.globalAlpha = 1;\n\n        // set canvas text styles\n        context.fillStyle = this._generateFillStyle(style, lines);\n\n        // draw lines line by line\n        for (let i = 0; i < lines.length; i++)\n        {\n            linePositionX = style.strokeThickness / 2;\n            linePositionY = ((style.strokeThickness / 2) + (i * lineHeight)) + fontProperties.ascent;\n\n            if (style.align === 'right')\n            {\n                linePositionX += maxLineWidth - lineWidths[i];\n            }\n            else if (style.align === 'center')\n            {\n                linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n            }\n\n            if (style.stroke && style.strokeThickness)\n            {\n                this.drawLetterSpacing(\n                    lines[i],\n                    linePositionX + style.padding,\n                    linePositionY + style.padding,\n                    true\n                );\n            }\n\n            if (style.fill)\n            {\n                this.drawLetterSpacing(\n                    lines[i],\n                    linePositionX + style.padding,\n                    linePositionY + style.padding\n                );\n            }\n        }\n\n        this.updateTexture();\n    }\n\n    /**\n     * Render the text with letter-spacing.\n     * @param {string} text - The text to draw\n     * @param {number} x - Horizontal position to draw the text\n     * @param {number} y - Vertical position to draw the text\n     * @param {boolean} [isStroke=false] - Is this drawing for the outside stroke of the\n     *  text? If not, it's for the inside fill\n     * @private\n     */\n    drawLetterSpacing(text, x, y, isStroke = false)\n    {\n        const style = this._style;\n\n        // letterSpacing of 0 means normal\n        const letterSpacing = style.letterSpacing;\n\n        if (letterSpacing === 0)\n        {\n            if (isStroke)\n            {\n                this.context.strokeText(text, x, y);\n            }\n            else\n            {\n                this.context.fillText(text, x, y);\n            }\n\n            return;\n        }\n\n        const characters = String.prototype.split.call(text, '');\n        let currentPosition = x;\n        let index = 0;\n        let current = '';\n        let previousWidth = this.context.measureText(text).width;\n        let currentWidth = 0;\n\n        while (index < text.length)\n        {\n            current = characters[index++];\n            if (isStroke)\n            {\n                this.context.strokeText(current, currentPosition, y);\n            }\n            else\n            {\n                this.context.fillText(current, currentPosition, y);\n            }\n            currentWidth = this.context.measureText(text.substring(index)).width;\n            currentPosition += previousWidth - currentWidth + letterSpacing;\n            previousWidth = currentWidth;\n        }\n    }\n\n    /**\n     * Updates texture size based on canvas size\n     *\n     * @private\n     */\n    updateTexture()\n    {\n        const canvas = this.canvas;\n\n        if (this._style.trim)\n        {\n            const trimmed = trimCanvas(canvas);\n\n            if (trimmed.data)\n            {\n                canvas.width = trimmed.width;\n                canvas.height = trimmed.height;\n                this.context.putImageData(trimmed.data, 0, 0);\n            }\n        }\n\n        const texture = this._texture;\n        const style = this._style;\n        const padding = style.trim ? 0 : style.padding;\n        const baseTexture = texture.baseTexture;\n\n        baseTexture.hasLoaded = true;\n        baseTexture.resolution = this.resolution;\n\n        baseTexture.realWidth = canvas.width;\n        baseTexture.realHeight = canvas.height;\n        baseTexture.width = canvas.width / this.resolution;\n        baseTexture.height = canvas.height / this.resolution;\n\n        texture.trim.width = texture._frame.width = canvas.width / this.resolution;\n        texture.trim.height = texture._frame.height = canvas.height / this.resolution;\n        texture.trim.x = -padding;\n        texture.trim.y = -padding;\n\n        texture.orig.width = texture._frame.width - (padding * 2);\n        texture.orig.height = texture._frame.height - (padding * 2);\n\n        // call sprite onTextureUpdate to update scale if _width or _height were set\n        this._onTextureUpdate();\n\n        baseTexture.emit('update', baseTexture);\n\n        this.dirty = false;\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @param {PIXI.WebGLRenderer} renderer - The renderer\n     */\n    renderWebGL(renderer)\n    {\n        if (this.resolution !== renderer.resolution)\n        {\n            this.resolution = renderer.resolution;\n            this.dirty = true;\n        }\n\n        this.updateText(true);\n\n        super.renderWebGL(renderer);\n    }\n\n    /**\n     * Renders the object using the Canvas renderer\n     *\n     * @private\n     * @param {PIXI.CanvasRenderer} renderer - The renderer\n     */\n    _renderCanvas(renderer)\n    {\n        if (this.resolution !== renderer.resolution)\n        {\n            this.resolution = renderer.resolution;\n            this.dirty = true;\n        }\n\n        this.updateText(true);\n\n        super._renderCanvas(renderer);\n    }\n\n    /**\n     * Gets the local bounds of the text object.\n     *\n     * @param {Rectangle} rect - The output rectangle.\n     * @return {Rectangle} The bounds.\n     */\n    getLocalBounds(rect)\n    {\n        this.updateText(true);\n\n        return super.getLocalBounds.call(this, rect);\n    }\n\n    /**\n     * calculates the bounds of the Text as a rectangle. The bounds calculation takes the worldTransform into account.\n     */\n    _calculateBounds()\n    {\n        this.updateText(true);\n        this.calculateVertices();\n        // if we have already done this on THIS frame.\n        this._bounds.addQuad(this.vertexData);\n    }\n\n    /**\n     * Method to be called upon a TextStyle change.\n     * @private\n     */\n    _onStyleChange()\n    {\n        this.dirty = true;\n    }\n\n    /**\n     * Generates the fill style. Can automatically generate a gradient based on the fill style being an array\n     *\n     * @private\n     * @param {object} style - The style.\n     * @param {string[]} lines - The lines of text.\n     * @return {string|number|CanvasGradient} The fill style\n     */\n    _generateFillStyle(style, lines)\n    {\n        if (!Array.isArray(style.fill))\n        {\n            return style.fill;\n        }\n\n        // cocoon on canvas+ cannot generate textures, so use the first colour instead\n        if (navigator.isCocoonJS)\n        {\n            return style.fill[0];\n        }\n\n        // the gradient will be evenly spaced out according to how large the array is.\n        // ['#FF0000', '#00FF00', '#0000FF'] would created stops at 0.25, 0.5 and 0.75\n        let gradient;\n        let totalIterations;\n        let currentIteration;\n        let stop;\n\n        const width = this.canvas.width / this.resolution;\n        const height = this.canvas.height / this.resolution;\n\n        // make a copy of the style settings, so we can manipulate them later\n        const fill = style.fill.slice();\n        const fillGradientStops = style.fillGradientStops.slice();\n\n        // wanting to evenly distribute the fills. So an array of 4 colours should give fills of 0.25, 0.5 and 0.75\n        if (!fillGradientStops.length)\n        {\n            const lengthPlus1 = fill.length + 1;\n\n            for (let i = 1; i < lengthPlus1; ++i)\n            {\n                fillGradientStops.push(i / lengthPlus1);\n            }\n        }\n\n        // stop the bleeding of the last gradient on the line above to the top gradient of the this line\n        // by hard defining the first gradient colour at point 0, and last gradient colour at point 1\n        fill.unshift(style.fill[0]);\n        fillGradientStops.unshift(0);\n\n        fill.push(style.fill[style.fill.length - 1]);\n        fillGradientStops.push(1);\n\n        if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL)\n        {\n            // start the gradient at the top center of the canvas, and end at the bottom middle of the canvas\n            gradient = this.context.createLinearGradient(width / 2, 0, width / 2, height);\n\n            // we need to repeat the gradient so that each individual line of text has the same vertical gradient effect\n            // ['#FF0000', '#00FF00', '#0000FF'] over 2 lines would create stops at 0.125, 0.25, 0.375, 0.625, 0.75, 0.875\n            totalIterations = (fill.length + 1) * lines.length;\n            currentIteration = 0;\n            for (let i = 0; i < lines.length; i++)\n            {\n                currentIteration += 1;\n                for (let j = 0; j < fill.length; j++)\n                {\n                    if (typeof fillGradientStops[j] === 'number')\n                    {\n                        stop = (fillGradientStops[j] / lines.length) + (i / lines.length);\n                    }\n                    else\n                    {\n                        stop = currentIteration / totalIterations;\n                    }\n                    gradient.addColorStop(stop, fill[j]);\n                    currentIteration++;\n                }\n            }\n        }\n        else\n        {\n            // start the gradient at the center left of the canvas, and end at the center right of the canvas\n            gradient = this.context.createLinearGradient(0, height / 2, width, height / 2);\n\n            // can just evenly space out the gradients in this case, as multiple lines makes no difference\n            // to an even left to right gradient\n            totalIterations = fill.length + 1;\n            currentIteration = 1;\n\n            for (let i = 0; i < fill.length; i++)\n            {\n                if (typeof fillGradientStops[i] === 'number')\n                {\n                    stop = fillGradientStops[i];\n                }\n                else\n                {\n                    stop = currentIteration / totalIterations;\n                }\n                gradient.addColorStop(stop, fill[i]);\n                currentIteration++;\n            }\n        }\n\n        return gradient;\n    }\n\n    /**\n     * Destroys this text object.\n     * Note* Unlike a Sprite, a Text object will automatically destroy its baseTexture and texture as\n     * the majority of the time the texture will not be shared with any other Sprites.\n     *\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their\n     *  destroy method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=true] - Should it destroy the current texture of the sprite as well\n     * @param {boolean} [options.baseTexture=true] - Should it destroy the base texture of the sprite as well\n     */\n    destroy(options)\n    {\n        if (typeof options === 'boolean')\n        {\n            options = { children: options };\n        }\n\n        options = Object.assign({}, defaultDestroyOptions, options);\n\n        super.destroy(options);\n\n        // make sure to reset the the context and canvas.. dont want this hanging around in memory!\n        this.context = null;\n        this.canvas = null;\n\n        this._style = null;\n    }\n\n    /**\n     * The width of the Text, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n    get width()\n    {\n        this.updateText(true);\n\n        return Math.abs(this.scale.x) * this._texture.orig.width;\n    }\n\n    set width(value) // eslint-disable-line require-jsdoc\n    {\n        this.updateText(true);\n\n        const s = sign(this.scale.x) || 1;\n\n        this.scale.x = s * value / this._texture.orig.width;\n        this._width = value;\n    }\n\n    /**\n     * The height of the Text, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n    get height()\n    {\n        this.updateText(true);\n\n        return Math.abs(this.scale.y) * this._texture.orig.height;\n    }\n\n    set height(value) // eslint-disable-line require-jsdoc\n    {\n        this.updateText(true);\n\n        const s = sign(this.scale.y) || 1;\n\n        this.scale.y = s * value / this._texture.orig.height;\n        this._height = value;\n    }\n\n    /**\n     * Set the style of the text. Set up an event listener to listen for changes on the style\n     * object and mark the text as dirty.\n     *\n     * @member {object|PIXI.TextStyle}\n     */\n    get style()\n    {\n        return this._style;\n    }\n\n    set style(style) // eslint-disable-line require-jsdoc\n    {\n        style = style || {};\n\n        if (style instanceof TextStyle)\n        {\n            this._style = style;\n        }\n        else\n        {\n            this._style = new TextStyle(style);\n        }\n\n        this.localStyleID = -1;\n        this.dirty = true;\n    }\n\n    /**\n     * Set the copy for the text object. To split a line you can use '\\n'.\n     *\n     * @member {string}\n     */\n    get text()\n    {\n        return this._text;\n    }\n\n    set text(text) // eslint-disable-line require-jsdoc\n    {\n        text = String(text === '' || text === null || text === undefined ? ' ' : text);\n\n        if (this._text === text)\n        {\n            return;\n        }\n        this._text = text;\n        this.dirty = true;\n    }\n}\n"]}