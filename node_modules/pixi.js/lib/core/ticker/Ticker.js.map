{"version":3,"sources":["../../../src/core/ticker/Ticker.js"],"names":["Ticker","_head","Infinity","_requestId","_maxElapsedMS","autoStart","deltaTime","elapsedMS","TARGET_FPMS","lastTime","speed","started","_tick","time","update","next","requestAnimationFrame","_requestIfNeeded","performance","now","_cancelIfNeeded","cancelAnimationFrame","_startIfPossible","start","add","fn","context","priority","NORMAL","_addListener","addOnce","listener","current","previous","connect","remove","match","destroy","stop","currentTime","head","emit","fps","minFPMS","Math","min","max"],"mappings":"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","file":"Ticker.js","sourcesContent":["import settings from '../settings';\nimport { UPDATE_PRIORITY } from '../const';\nimport TickerListener from './TickerListener';\n\n/**\n * A Ticker class that runs an update loop that other objects listen to.\n * This class is composed around listeners\n * meant for execution on the next requested animation frame.\n * Animation frames are requested only when necessary,\n * e.g. When the ticker is started and the emitter has listeners.\n *\n * @class\n * @memberof PIXI.ticker\n */\nexport default class Ticker\n{\n    /**\n     *\n     */\n    constructor()\n    {\n        /**\n         * The first listener. All new listeners added are chained on this.\n         * @private\n         * @type {TickerListener}\n         */\n        this._head = new TickerListener(null, null, Infinity);\n\n        /**\n         * Internal current frame request ID\n         * @private\n         */\n        this._requestId = null;\n\n        /**\n         * Internal value managed by minFPS property setter and getter.\n         * This is the maximum allowed milliseconds between updates.\n         * @private\n         */\n        this._maxElapsedMS = 100;\n\n        /**\n         * Whether or not this ticker should invoke the method\n         * {@link PIXI.ticker.Ticker#start} automatically\n         * when a listener is added.\n         *\n         * @member {boolean}\n         * @default false\n         */\n        this.autoStart = false;\n\n        /**\n         * Scalar time value from last frame to this frame.\n         * This value is capped by setting {@link PIXI.ticker.Ticker#minFPS}\n         * and is scaled with {@link PIXI.ticker.Ticker#speed}.\n         * **Note:** The cap may be exceeded by scaling.\n         *\n         * @member {number}\n         * @default 1\n         */\n        this.deltaTime = 1;\n\n        /**\n         * Time elapsed in milliseconds from last frame to this frame.\n         * Opposed to what the scalar {@link PIXI.ticker.Ticker#deltaTime}\n         * is based, this value is neither capped nor scaled.\n         * If the platform supports DOMHighResTimeStamp,\n         * this value will have a precision of 1 µs.\n         * Defaults to target frame time\n         *\n         * @member {number}\n         * @default 16.66\n         */\n        this.elapsedMS = 1 / settings.TARGET_FPMS;\n\n        /**\n         * The last time {@link PIXI.ticker.Ticker#update} was invoked.\n         * This value is also reset internally outside of invoking\n         * update, but only when a new animation frame is requested.\n         * If the platform supports DOMHighResTimeStamp,\n         * this value will have a precision of 1 µs.\n         *\n         * @member {number}\n         * @default -1\n         */\n        this.lastTime = -1;\n\n        /**\n         * Factor of current {@link PIXI.ticker.Ticker#deltaTime}.\n         * @example\n         * // Scales ticker.deltaTime to what would be\n         * // the equivalent of approximately 120 FPS\n         * ticker.speed = 2;\n         *\n         * @member {number}\n         * @default 1\n         */\n        this.speed = 1;\n\n        /**\n         * Whether or not this ticker has been started.\n         * `true` if {@link PIXI.ticker.Ticker#start} has been called.\n         * `false` if {@link PIXI.ticker.Ticker#stop} has been called.\n         * While `false`, this value may change to `true` in the\n         * event of {@link PIXI.ticker.Ticker#autoStart} being `true`\n         * and a listener is added.\n         *\n         * @member {boolean}\n         * @default false\n         */\n        this.started = false;\n\n        /**\n         * Internal tick method bound to ticker instance.\n         * This is because in early 2015, Function.bind\n         * is still 60% slower in high performance scenarios.\n         * Also separating frame requests from update method\n         * so listeners may be called at any time and with\n         * any animation API, just invoke ticker.update(time).\n         *\n         * @private\n         * @param {number} time - Time since last tick.\n         */\n        this._tick = (time) =>\n        {\n            this._requestId = null;\n\n            if (this.started)\n            {\n                // Invoke listeners now\n                this.update(time);\n                // Listener side effects may have modified ticker state.\n                if (this.started && this._requestId === null && this._head.next)\n                {\n                    this._requestId = requestAnimationFrame(this._tick);\n                }\n            }\n        };\n    }\n\n    /**\n     * Conditionally requests a new animation frame.\n     * If a frame has not already been requested, and if the internal\n     * emitter has listeners, a new frame is requested.\n     *\n     * @private\n     */\n    _requestIfNeeded()\n    {\n        if (this._requestId === null && this._head.next)\n        {\n            // ensure callbacks get correct delta\n            this.lastTime = performance.now();\n            this._requestId = requestAnimationFrame(this._tick);\n        }\n    }\n\n    /**\n     * Conditionally cancels a pending animation frame.\n     *\n     * @private\n     */\n    _cancelIfNeeded()\n    {\n        if (this._requestId !== null)\n        {\n            cancelAnimationFrame(this._requestId);\n            this._requestId = null;\n        }\n    }\n\n    /**\n     * Conditionally requests a new animation frame.\n     * If the ticker has been started it checks if a frame has not already\n     * been requested, and if the internal emitter has listeners. If these\n     * conditions are met, a new frame is requested. If the ticker has not\n     * been started, but autoStart is `true`, then the ticker starts now,\n     * and continues with the previous conditions to request a new frame.\n     *\n     * @private\n     */\n    _startIfPossible()\n    {\n        if (this.started)\n        {\n            this._requestIfNeeded();\n        }\n        else if (this.autoStart)\n        {\n            this.start();\n        }\n    }\n\n    /**\n     * Register a handler for tick events. Calls continuously unless\n     * it is removed or the ticker is stopped.\n     *\n     * @param {Function} fn - The listener function to be added for updates\n     * @param {Function} [context] - The listener context\n     * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting\n     * @returns {PIXI.ticker.Ticker} This instance of a ticker\n     */\n    add(fn, context, priority = UPDATE_PRIORITY.NORMAL)\n    {\n        return this._addListener(new TickerListener(fn, context, priority));\n    }\n\n    /**\n     * Add a handler for the tick event which is only execute once.\n     *\n     * @param {Function} fn - The listener function to be added for one update\n     * @param {Function} [context] - The listener context\n     * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting\n     * @returns {PIXI.ticker.Ticker} This instance of a ticker\n     */\n    addOnce(fn, context, priority = UPDATE_PRIORITY.NORMAL)\n    {\n        return this._addListener(new TickerListener(fn, context, priority, true));\n    }\n\n    /**\n     * Internally adds the event handler so that it can be sorted by priority.\n     * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run\n     * before the rendering.\n     *\n     * @private\n     * @param {TickerListener} listener - Current listener being added.\n     * @returns {PIXI.ticker.Ticker} This instance of a ticker\n     */\n    _addListener(listener)\n    {\n        // For attaching to head\n        let current = this._head.next;\n        let previous = this._head;\n\n        // Add the first item\n        if (!current)\n        {\n            listener.connect(previous);\n        }\n        else\n        {\n            // Go from highest to lowest priority\n            while (current)\n            {\n                if (listener.priority > current.priority)\n                {\n                    listener.connect(previous);\n                    break;\n                }\n                previous = current;\n                current = current.next;\n            }\n\n            // Not yet connected\n            if (!listener.previous)\n            {\n                listener.connect(previous);\n            }\n        }\n\n        this._startIfPossible();\n\n        return this;\n    }\n\n    /**\n     * Removes any handlers matching the function and context parameters.\n     * If no handlers are left after removing, then it cancels the animation frame.\n     *\n     * @param {Function} fn - The listener function to be removed\n     * @param {Function} [context] - The listener context to be removed\n     * @returns {PIXI.ticker.Ticker} This instance of a ticker\n     */\n    remove(fn, context)\n    {\n        let listener = this._head.next;\n\n        while (listener)\n        {\n            // We found a match, lets remove it\n            // no break to delete all possible matches\n            // incase a listener was added 2+ times\n            if (listener.match(fn, context))\n            {\n                listener = listener.destroy();\n            }\n            else\n            {\n                listener = listener.next;\n            }\n        }\n\n        if (!this._head.next)\n        {\n            this._cancelIfNeeded();\n        }\n\n        return this;\n    }\n\n    /**\n     * Starts the ticker. If the ticker has listeners\n     * a new animation frame is requested at this point.\n     */\n    start()\n    {\n        if (!this.started)\n        {\n            this.started = true;\n            this._requestIfNeeded();\n        }\n    }\n\n    /**\n     * Stops the ticker. If the ticker has requested\n     * an animation frame it is canceled at this point.\n     */\n    stop()\n    {\n        if (this.started)\n        {\n            this.started = false;\n            this._cancelIfNeeded();\n        }\n    }\n\n    /**\n     * Destroy the ticker and don't use after this. Calling\n     * this method removes all references to internal events.\n     */\n    destroy()\n    {\n        this.stop();\n\n        let listener = this._head.next;\n\n        while (listener)\n        {\n            listener = listener.destroy(true);\n        }\n\n        this._head.destroy();\n        this._head = null;\n    }\n\n    /**\n     * Triggers an update. An update entails setting the\n     * current {@link PIXI.ticker.Ticker#elapsedMS},\n     * the current {@link PIXI.ticker.Ticker#deltaTime},\n     * invoking all listeners with current deltaTime,\n     * and then finally setting {@link PIXI.ticker.Ticker#lastTime}\n     * with the value of currentTime that was provided.\n     * This method will be called automatically by animation\n     * frame callbacks if the ticker instance has been started\n     * and listeners are added.\n     *\n     * @param {number} [currentTime=performance.now()] - the current time of execution\n     */\n    update(currentTime = performance.now())\n    {\n        let elapsedMS;\n\n        // If the difference in time is zero or negative, we ignore most of the work done here.\n        // If there is no valid difference, then should be no reason to let anyone know about it.\n        // A zero delta, is exactly that, nothing should update.\n        //\n        // The difference in time can be negative, and no this does not mean time traveling.\n        // This can be the result of a race condition between when an animation frame is requested\n        // on the current JavaScript engine event loop, and when the ticker's start method is invoked\n        // (which invokes the internal _requestIfNeeded method). If a frame is requested before\n        // _requestIfNeeded is invoked, then the callback for the animation frame the ticker requests,\n        // can receive a time argument that can be less than the lastTime value that was set within\n        // _requestIfNeeded. This difference is in microseconds, but this is enough to cause problems.\n        //\n        // This check covers this browser engine timing issue, as well as if consumers pass an invalid\n        // currentTime value. This may happen if consumers opt-out of the autoStart, and update themselves.\n\n        if (currentTime > this.lastTime)\n        {\n            // Save uncapped elapsedMS for measurement\n            elapsedMS = this.elapsedMS = currentTime - this.lastTime;\n\n            // cap the milliseconds elapsed used for deltaTime\n            if (elapsedMS > this._maxElapsedMS)\n            {\n                elapsedMS = this._maxElapsedMS;\n            }\n\n            this.deltaTime = elapsedMS * settings.TARGET_FPMS * this.speed;\n\n            // Cache a local reference, in-case ticker is destroyed\n            // during the emit, we can still check for head.next\n            const head = this._head;\n\n            // Invoke listeners added to internal emitter\n            let listener = head.next;\n\n            while (listener)\n            {\n                listener = listener.emit(this.deltaTime);\n            }\n\n            if (!head.next)\n            {\n                this._cancelIfNeeded();\n            }\n        }\n        else\n        {\n            this.deltaTime = this.elapsedMS = 0;\n        }\n\n        this.lastTime = currentTime;\n    }\n\n    /**\n     * The frames per second at which this ticker is running.\n     * The default is approximately 60 in most modern browsers.\n     * **Note:** This does not factor in the value of\n     * {@link PIXI.ticker.Ticker#speed}, which is specific\n     * to scaling {@link PIXI.ticker.Ticker#deltaTime}.\n     *\n     * @member {number}\n     * @readonly\n     */\n    get FPS()\n    {\n        return 1000 / this.elapsedMS;\n    }\n\n    /**\n     * Manages the maximum amount of milliseconds allowed to\n     * elapse between invoking {@link PIXI.ticker.Ticker#update}.\n     * This value is used to cap {@link PIXI.ticker.Ticker#deltaTime},\n     * but does not effect the measured value of {@link PIXI.ticker.Ticker#FPS}.\n     * When setting this property it is clamped to a value between\n     * `0` and `PIXI.settings.TARGET_FPMS * 1000`.\n     *\n     * @member {number}\n     * @default 10\n     */\n    get minFPS()\n    {\n        return 1000 / this._maxElapsedMS;\n    }\n\n    set minFPS(fps) // eslint-disable-line require-jsdoc\n    {\n        // Clamp: 0 to TARGET_FPMS\n        const minFPMS = Math.min(Math.max(0, fps) / 1000, settings.TARGET_FPMS);\n\n        this._maxElapsedMS = 1 / minFPMS;\n    }\n}\n"]}