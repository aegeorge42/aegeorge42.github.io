{"version":3,"sources":["../../../src/core/ticker/TickerListener.js"],"names":["TickerListener","fn","context","priority","once","next","previous","_destroyed","match","emit","deltaTime","call","redirect","destroy","connect","hard"],"mappings":";;;;;;AAAA;;;;;;;IAOqBA,c;AAEjB;;;;;;;;AAQA,4BAAYC,EAAZ,EACA;AAAA,YADgBC,OAChB,uEAD0B,IAC1B;AAAA,YADgCC,QAChC,uEAD2C,CAC3C;AAAA,YAD8CC,IAC9C,uEADqD,KACrD;;AAAA;;AACI;;;;AAIA,aAAKH,EAAL,GAAUA,EAAV;;AAEA;;;;AAIA,aAAKC,OAAL,GAAeA,OAAf;;AAEA;;;;AAIA,aAAKC,QAAL,GAAgBA,QAAhB;;AAEA;;;;AAIA,aAAKC,IAAL,GAAYA,IAAZ;;AAEA;;;;AAIA,aAAKC,IAAL,GAAY,IAAZ;;AAEA;;;;AAIA,aAAKC,QAAL,GAAgB,IAAhB;;AAEA;;;;;AAKA,aAAKC,UAAL,GAAkB,KAAlB;AACH;;AAED;;;;;;;;;6BAOAC,K,kBAAMP,E,EAAIC,O,EACV;AACIA,kBAAUA,WAAW,IAArB;;AAEA,eAAO,KAAKD,EAAL,KAAYA,EAAZ,IAAkB,KAAKC,OAAL,KAAiBA,OAA1C;AACH,K;;AAED;;;;;;;6BAKAO,I,iBAAKC,S,EACL;AACI,YAAI,KAAKT,EAAT,EACA;AACI,gBAAI,KAAKC,OAAT,EACA;AACI,qBAAKD,EAAL,CAAQU,IAAR,CAAa,KAAKT,OAAlB,EAA2BQ,SAA3B;AACH,aAHD,MAKA;AACI,qBAAKT,EAAL,CAAQS,SAAR;AACH;AACJ;;AAED,YAAME,WAAW,KAAKP,IAAtB;;AAEA,YAAI,KAAKD,IAAT,EACA;AACI,iBAAKS,OAAL,CAAa,IAAb;AACH;;AAED;AACA;AACA,YAAI,KAAKN,UAAT,EACA;AACI,iBAAKF,IAAL,GAAY,IAAZ;AACH;;AAED,eAAOO,QAAP;AACH,K;;AAED;;;;;;6BAIAE,O,oBAAQR,Q,EACR;AACI,aAAKA,QAAL,GAAgBA,QAAhB;AACA,YAAIA,SAASD,IAAb,EACA;AACIC,qBAASD,IAAT,CAAcC,QAAd,GAAyB,IAAzB;AACH;AACD,aAAKD,IAAL,GAAYC,SAASD,IAArB;AACAC,iBAASD,IAAT,GAAgB,IAAhB;AACH,K;;AAED;;;;;;;;6BAMAQ,O,sBACA;AAAA,YADQE,IACR,uEADe,KACf;;AACI,aAAKR,UAAL,GAAkB,IAAlB;AACA,aAAKN,EAAL,GAAU,IAAV;AACA,aAAKC,OAAL,GAAe,IAAf;;AAEA;AACA,YAAI,KAAKI,QAAT,EACA;AACI,iBAAKA,QAAL,CAAcD,IAAd,GAAqB,KAAKA,IAA1B;AACH;;AAED,YAAI,KAAKA,IAAT,EACA;AACI,iBAAKA,IAAL,CAAUC,QAAV,GAAqB,KAAKA,QAA1B;AACH;;AAED;AACA,YAAMM,WAAW,KAAKP,IAAtB;;AAEA;AACA,aAAKA,IAAL,GAAYU,OAAO,IAAP,GAAcH,QAA1B;AACA,aAAKN,QAAL,GAAgB,IAAhB;;AAEA,eAAOM,QAAP;AACH,K;;;;;kBAxJgBZ,c","file":"TickerListener.js","sourcesContent":["/**\n * Internal class for handling the priority sorting of ticker handlers.\n *\n * @private\n * @class\n * @memberof PIXI.ticker\n */\nexport default class TickerListener\n{\n    /**\n     * Constructor\n     *\n     * @param {Function} fn - The listener function to be added for one update\n     * @param {Function} [context=null] - The listener context\n     * @param {number} [priority=0] - The priority for emitting\n     * @param {boolean} [once=false] - If the handler should fire once\n     */\n    constructor(fn, context = null, priority = 0, once = false)\n    {\n        /**\n         * The handler function to execute.\n         * @member {Function}\n         */\n        this.fn = fn;\n\n        /**\n         * The calling to execute.\n         * @member {Function}\n         */\n        this.context = context;\n\n        /**\n         * The current priority.\n         * @member {number}\n         */\n        this.priority = priority;\n\n        /**\n         * If this should only execute once.\n         * @member {boolean}\n         */\n        this.once = once;\n\n        /**\n         * The next item in chain.\n         * @member {TickerListener}\n         */\n        this.next = null;\n\n        /**\n         * The previous item in chain.\n         * @member {TickerListener}\n         */\n        this.previous = null;\n\n        /**\n         * `true` if this listener has been destroyed already.\n         * @member {boolean}\n         * @private\n         */\n        this._destroyed = false;\n    }\n\n    /**\n     * Simple compare function to figure out if a function and context match.\n     *\n     * @param {Function} fn - The listener function to be added for one update\n     * @param {Function} context - The listener context\n     * @return {boolean} `true` if the listener match the arguments\n     */\n    match(fn, context)\n    {\n        context = context || null;\n\n        return this.fn === fn && this.context === context;\n    }\n\n    /**\n     * Emit by calling the current function.\n     * @param {number} deltaTime - time since the last emit.\n     * @return {TickerListener} Next ticker\n     */\n    emit(deltaTime)\n    {\n        if (this.fn)\n        {\n            if (this.context)\n            {\n                this.fn.call(this.context, deltaTime);\n            }\n            else\n            {\n                this.fn(deltaTime);\n            }\n        }\n\n        const redirect = this.next;\n\n        if (this.once)\n        {\n            this.destroy(true);\n        }\n\n        // Soft-destroying should remove\n        // the next reference\n        if (this._destroyed)\n        {\n            this.next = null;\n        }\n\n        return redirect;\n    }\n\n    /**\n     * Connect to the list.\n     * @param {TickerListener} previous - Input node, previous listener\n     */\n    connect(previous)\n    {\n        this.previous = previous;\n        if (previous.next)\n        {\n            previous.next.previous = this;\n        }\n        this.next = previous.next;\n        previous.next = this;\n    }\n\n    /**\n     * Destroy and don't use after this.\n     * @param {boolean} [hard = false] `true` to remove the `next` reference, this\n     *        is considered a hard destroy. Soft destroy maintains the next reference.\n     * @return {TickerListener} The listener to redirect while emitting or removing.\n     */\n    destroy(hard = false)\n    {\n        this._destroyed = true;\n        this.fn = null;\n        this.context = null;\n\n        // Disconnect, hook up next and previous\n        if (this.previous)\n        {\n            this.previous.next = this.next;\n        }\n\n        if (this.next)\n        {\n            this.next.previous = this.previous;\n        }\n\n        // Redirect to the next item\n        const redirect = this.next;\n\n        // Remove references\n        this.next = hard ? null : redirect;\n        this.previous = null;\n\n        return redirect;\n    }\n}\n"]}