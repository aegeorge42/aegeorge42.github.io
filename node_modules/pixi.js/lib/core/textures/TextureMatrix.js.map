{"version":3,"sources":["../../../src/core/textures/TextureMatrix.js"],"names":["tempMat","TextureMatrix","texture","clampMargin","_texture","mapCoord","uClampFrame","Float32Array","uClampOffset","_lastTextureID","clampOffset","multiplyUvs","uvs","out","undefined","mat","i","length","x","y","a","c","tx","b","d","ty","update","forceUpdate","tex","valid","_updateID","_uvs","set","x1","x0","y1","y0","x3","y3","orig","trim","width","height","append","texBase","baseTexture","frame","margin","resolution","offset","_frame","realWidth","realHeight","value"],"mappings":"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","file":"TextureMatrix.js","sourcesContent":["import { default as Matrix } from '../math/Matrix';\n\nconst tempMat = new Matrix();\n\n/**\n * Class controls uv transform and frame clamp for texture\n * Can be used in Texture \"transform\" field, or separately, you can use different clamp settings on the same texture.\n * If you want to add support for texture region of certain feature or filter, that's what you're looking for.\n *\n * @see PIXI.Texture\n * @see PIXI.mesh.Mesh\n * @see PIXI.extras.TilingSprite\n * @class\n * @memberof PIXI\n */\nexport default class TextureMatrix\n{\n    /**\n     *\n     * @param {PIXI.Texture} texture observed texture\n     * @param {number} [clampMargin] Changes frame clamping, 0.5 by default. Use -0.5 for extra border.\n     * @constructor\n     */\n    constructor(texture, clampMargin)\n    {\n        this._texture = texture;\n\n        this.mapCoord = new Matrix();\n\n        this.uClampFrame = new Float32Array(4);\n\n        this.uClampOffset = new Float32Array(2);\n\n        this._lastTextureID = -1;\n\n        /**\n         * Changes frame clamping\n         * Works with TilingSprite and Mesh\n         * Change to 1.5 if you texture has repeated right and bottom lines, that leads to smoother borders\n         *\n         * @default 0\n         * @member {number}\n         */\n        this.clampOffset = 0;\n\n        /**\n         * Changes frame clamping\n         * Works with TilingSprite and Mesh\n         * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n         *\n         * @default 0.5\n         * @member {number}\n         */\n        this.clampMargin = (typeof clampMargin === 'undefined') ? 0.5 : clampMargin;\n    }\n\n    /**\n     * texture property\n     * @member {PIXI.Texture}\n     */\n    get texture()\n    {\n        return this._texture;\n    }\n\n    set texture(value) // eslint-disable-line require-jsdoc\n    {\n        this._texture = value;\n        this._lastTextureID = -1;\n    }\n\n    /**\n     * Multiplies uvs array to transform\n     * @param {Float32Array} uvs mesh uvs\n     * @param {Float32Array} [out=uvs] output\n     * @returns {Float32Array} output\n     */\n    multiplyUvs(uvs, out)\n    {\n        if (out === undefined)\n        {\n            out = uvs;\n        }\n\n        const mat = this.mapCoord;\n\n        for (let i = 0; i < uvs.length; i += 2)\n        {\n            const x = uvs[i];\n            const y = uvs[i + 1];\n\n            out[i] = (x * mat.a) + (y * mat.c) + mat.tx;\n            out[i + 1] = (x * mat.b) + (y * mat.d) + mat.ty;\n        }\n\n        return out;\n    }\n\n    /**\n     * updates matrices if texture was changed\n     * @param {boolean} forceUpdate if true, matrices will be updated any case\n     * @returns {boolean} whether or not it was updated\n     */\n    update(forceUpdate)\n    {\n        const tex = this._texture;\n\n        if (!tex || !tex.valid)\n        {\n            return false;\n        }\n\n        if (!forceUpdate\n            && this._lastTextureID === tex._updateID)\n        {\n            return false;\n        }\n\n        this._lastTextureID = tex._updateID;\n\n        const uvs = tex._uvs;\n\n        this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);\n\n        const orig = tex.orig;\n        const trim = tex.trim;\n\n        if (trim)\n        {\n            tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height,\n                -trim.x / trim.width, -trim.y / trim.height);\n            this.mapCoord.append(tempMat);\n        }\n\n        const texBase = tex.baseTexture;\n        const frame = this.uClampFrame;\n        const margin = this.clampMargin / texBase.resolution;\n        const offset = this.clampOffset;\n\n        frame[0] = (tex._frame.x + margin + offset) / texBase.width;\n        frame[1] = (tex._frame.y + margin + offset) / texBase.height;\n        frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;\n        frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;\n        this.uClampOffset[0] = offset / texBase.realWidth;\n        this.uClampOffset[1] = offset / texBase.realHeight;\n\n        return true;\n    }\n}\n"]}