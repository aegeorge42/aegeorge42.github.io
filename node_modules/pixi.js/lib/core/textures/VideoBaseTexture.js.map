{"version":3,"sources":["../../../src/core/textures/VideoBaseTexture.js"],"names":["VideoBaseTexture","source","scaleMode","autoPlay","Error","readyState","HAVE_ENOUGH_DATA","HAVE_FUTURE_DATA","width","height","complete","videoWidth","videoHeight","_autoUpdate","_isAutoUpdating","update","bind","_onCanPlay","addEventListener","_onPlayStart","_onPlayStop","hasLoaded","__loaded","_isSourceReady","_isSourcePlaying","currentTime","paused","ended","autoUpdate","add","HIGH","remove","removeEventListener","emit","play","destroy","_pixiId","removeFromCache","pause","src","load","fromVideo","video","baseTexture","addToCache","fromUrl","videoSrc","crossorigin","document","createElement","setAttribute","url","Array","isArray","undefined","indexOf","crossOrigin","i","length","appendChild","createSource","mime","value","fromUrls","path","type","purePath","split","shift","toLowerCase","substr","lastIndexOf"],"mappings":"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","file":"VideoBaseTexture.js","sourcesContent":["import BaseTexture from './BaseTexture';\nimport { uid, BaseTextureCache } from '../utils';\nimport { shared } from '../ticker';\nimport { UPDATE_PRIORITY } from '../const';\nimport determineCrossOrigin from '../utils/determineCrossOrigin';\n\n/**\n * A texture of a [playing] Video.\n *\n * Video base textures mimic PixiJS BaseTexture.from.... method in their creation process.\n *\n * This can be used in several ways, such as:\n *\n * ```js\n * let texture = PIXI.VideoBaseTexture.fromUrl('http://mydomain.com/video.mp4');\n *\n * let texture = PIXI.VideoBaseTexture.fromUrl({ src: 'http://mydomain.com/video.mp4', mime: 'video/mp4' });\n *\n * let texture = PIXI.VideoBaseTexture.fromUrls(['/video.webm', '/video.mp4']);\n *\n * let texture = PIXI.VideoBaseTexture.fromUrls([\n *     { src: '/video.webm', mime: 'video/webm' },\n *     { src: '/video.mp4', mime: 'video/mp4' }\n * ]);\n * ```\n *\n * See the [\"deus\" demo](http://www.goodboydigital.com/pixijs/examples/deus/).\n *\n * @class\n * @extends PIXI.BaseTexture\n * @memberof PIXI\n */\nexport default class VideoBaseTexture extends BaseTexture\n{\n    /**\n     * @param {HTMLVideoElement} source - Video source\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n     * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded\n     */\n    constructor(source, scaleMode, autoPlay = true)\n    {\n        if (!source)\n        {\n            throw new Error('No video source element specified.');\n        }\n\n        // hook in here to check if video is already available.\n        // BaseTexture looks for a source.complete boolean, plus width & height.\n\n        if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA)\n            && source.width && source.height)\n        {\n            source.complete = true;\n        }\n\n        super(source, scaleMode);\n\n        this.width = source.videoWidth;\n        this.height = source.videoHeight;\n\n        this._autoUpdate = true;\n        this._isAutoUpdating = false;\n\n        /**\n         * When set to true will automatically play videos used by this texture once\n         * they are loaded. If false, it will not modify the playing state.\n         *\n         * @member {boolean}\n         * @default true\n         */\n        this.autoPlay = autoPlay;\n\n        this.update = this.update.bind(this);\n        this._onCanPlay = this._onCanPlay.bind(this);\n\n        source.addEventListener('play', this._onPlayStart.bind(this));\n        source.addEventListener('pause', this._onPlayStop.bind(this));\n        this.hasLoaded = false;\n        this.__loaded = false;\n\n        if (!this._isSourceReady())\n        {\n            source.addEventListener('canplay', this._onCanPlay);\n            source.addEventListener('canplaythrough', this._onCanPlay);\n        }\n        else\n        {\n            this._onCanPlay();\n        }\n    }\n\n    /**\n     * Returns true if the underlying source is playing.\n     *\n     * @private\n     * @return {boolean} True if playing.\n     */\n    _isSourcePlaying()\n    {\n        const source = this.source;\n\n        return (source.currentTime > 0 && source.paused === false && source.ended === false && source.readyState > 2);\n    }\n\n    /**\n     * Returns true if the underlying source is ready for playing.\n     *\n     * @private\n     * @return {boolean} True if ready.\n     */\n    _isSourceReady()\n    {\n        return this.source.readyState === 3 || this.source.readyState === 4;\n    }\n\n    /**\n     * Runs the update loop when the video is ready to play\n     *\n     * @private\n     */\n    _onPlayStart()\n    {\n        // Just in case the video has not received its can play even yet..\n        if (!this.hasLoaded)\n        {\n            this._onCanPlay();\n        }\n\n        if (!this._isAutoUpdating && this.autoUpdate)\n        {\n            shared.add(this.update, this, UPDATE_PRIORITY.HIGH);\n            this._isAutoUpdating = true;\n        }\n    }\n\n    /**\n     * Fired when a pause event is triggered, stops the update loop\n     *\n     * @private\n     */\n    _onPlayStop()\n    {\n        if (this._isAutoUpdating)\n        {\n            shared.remove(this.update, this);\n            this._isAutoUpdating = false;\n        }\n    }\n\n    /**\n     * Fired when the video is loaded and ready to play\n     *\n     * @private\n     */\n    _onCanPlay()\n    {\n        this.hasLoaded = true;\n\n        if (this.source)\n        {\n            this.source.removeEventListener('canplay', this._onCanPlay);\n            this.source.removeEventListener('canplaythrough', this._onCanPlay);\n\n            this.width = this.source.videoWidth;\n            this.height = this.source.videoHeight;\n\n            // prevent multiple loaded dispatches..\n            if (!this.__loaded)\n            {\n                this.__loaded = true;\n                this.emit('loaded', this);\n            }\n\n            if (this._isSourcePlaying())\n            {\n                this._onPlayStart();\n            }\n            else if (this.autoPlay)\n            {\n                this.source.play();\n            }\n        }\n    }\n\n    /**\n     * Destroys this texture\n     *\n     */\n    destroy()\n    {\n        if (this._isAutoUpdating)\n        {\n            shared.remove(this.update, this);\n        }\n\n        if (this.source && this.source._pixiId)\n        {\n            BaseTexture.removeFromCache(this.source._pixiId);\n            delete this.source._pixiId;\n\n            this.source.pause();\n            this.source.src = '';\n            this.source.load();\n        }\n\n        super.destroy();\n    }\n\n    /**\n     * Mimic PixiJS BaseTexture.from.... method.\n     *\n     * @static\n     * @param {HTMLVideoElement} video - Video to create texture from\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n     * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded\n     * @return {PIXI.VideoBaseTexture} Newly created VideoBaseTexture\n     */\n    static fromVideo(video, scaleMode, autoPlay)\n    {\n        if (!video._pixiId)\n        {\n            video._pixiId = `video_${uid()}`;\n        }\n\n        let baseTexture = BaseTextureCache[video._pixiId];\n\n        if (!baseTexture)\n        {\n            baseTexture = new VideoBaseTexture(video, scaleMode, autoPlay);\n            BaseTexture.addToCache(baseTexture, video._pixiId);\n        }\n\n        return baseTexture;\n    }\n\n    /**\n     * Helper function that creates a new BaseTexture based on the given video element.\n     * This BaseTexture can then be used to create a texture\n     *\n     * @static\n     * @param {string|object|string[]|object[]} videoSrc - The URL(s) for the video.\n     * @param {string} [videoSrc.src] - One of the source urls for the video\n     * @param {string} [videoSrc.mime] - The mimetype of the video (e.g. 'video/mp4'). If not specified\n     *  the url's extension will be used as the second part of the mime type.\n     * @param {number} scaleMode - See {@link PIXI.SCALE_MODES} for possible values\n     * @param {boolean} [crossorigin=(auto)] - Should use anonymous CORS? Defaults to true if the URL is not a data-URI.\n     * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded\n     * @return {PIXI.VideoBaseTexture} Newly created VideoBaseTexture\n     */\n    static fromUrl(videoSrc, scaleMode, crossorigin, autoPlay)\n    {\n        const video = document.createElement('video');\n\n        video.setAttribute('webkit-playsinline', '');\n        video.setAttribute('playsinline', '');\n\n        const url = Array.isArray(videoSrc) ? (videoSrc[0].src || videoSrc[0]) : (videoSrc.src || videoSrc);\n\n        if (crossorigin === undefined && url.indexOf('data:') !== 0)\n        {\n            video.crossOrigin = determineCrossOrigin(url);\n        }\n        else if (crossorigin)\n        {\n            video.crossOrigin = typeof crossorigin === 'string' ? crossorigin : 'anonymous';\n        }\n\n        // array of objects or strings\n        if (Array.isArray(videoSrc))\n        {\n            for (let i = 0; i < videoSrc.length; ++i)\n            {\n                video.appendChild(createSource(videoSrc[i].src || videoSrc[i], videoSrc[i].mime));\n            }\n        }\n        // single object or string\n        else\n        {\n            video.appendChild(createSource(url, videoSrc.mime));\n        }\n\n        video.load();\n\n        return VideoBaseTexture.fromVideo(video, scaleMode, autoPlay);\n    }\n\n    /**\n     * Should the base texture automatically update itself, set to true by default\n     *\n     * @member {boolean}\n     */\n    get autoUpdate()\n    {\n        return this._autoUpdate;\n    }\n\n    set autoUpdate(value) // eslint-disable-line require-jsdoc\n    {\n        if (value !== this._autoUpdate)\n        {\n            this._autoUpdate = value;\n\n            if (!this._autoUpdate && this._isAutoUpdating)\n            {\n                shared.remove(this.update, this);\n                this._isAutoUpdating = false;\n            }\n            else if (this._autoUpdate && !this._isAutoUpdating)\n            {\n                shared.add(this.update, this, UPDATE_PRIORITY.HIGH);\n                this._isAutoUpdating = true;\n            }\n        }\n    }\n}\n\nVideoBaseTexture.fromUrls = VideoBaseTexture.fromUrl;\n\nfunction createSource(path, type)\n{\n    if (!type)\n    {\n        const purePath = path.split('?').shift().toLowerCase();\n\n        type = `video/${purePath.substr(purePath.lastIndexOf('.') + 1)}`;\n    }\n\n    const source = document.createElement('source');\n\n    source.src = path;\n    source.type = type;\n\n    return source;\n}\n"]}