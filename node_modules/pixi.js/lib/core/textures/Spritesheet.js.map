{"version":3,"sources":["../../../src/core/textures/Spritesheet.js"],"names":["Spritesheet","baseTexture","data","resolutionFilename","textures","animations","resolution","_updateResolution","imageUrl","_frames","frames","_frameKeys","Object","keys","_batchIndex","_callback","scale","meta","undefined","parseFloat","update","parse","callback","length","BATCH_SIZE","_processFrames","_processAnimations","_parseComplete","_nextBatch","initialFrameIndex","frameIndex","maxFrames","sourceScale","i","rect","frame","trim","sourceSize","trimmed","orig","Math","floor","w","h","rotated","x","y","spriteSourceSize","anchor","addToCache","animName","frameName","push","call","setTimeout","destroy","destroyBase"],"mappings":"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","file":"Spritesheet.js","sourcesContent":["import { Rectangle, Texture } from '../';\nimport { getResolutionOfUrl } from '../utils';\n\n/**\n * Utility class for maintaining reference to a collection\n * of Textures on a single Spritesheet.\n *\n * To access a sprite sheet from your code pass its JSON data file to Pixi's loader:\n *\n * ```js\n * PIXI.loader.add(\"images/spritesheet.json\").load(setup);\n *\n * function setup() {\n *   let sheet = PIXI.loader.resources[\"images/spritesheet.json\"].spritesheet;\n *   ...\n * }\n * ```\n * With the `sheet.textures` you can create Sprite objects,`sheet.animations` can be used to create an AnimatedSprite.\n *\n * Sprite sheets can be packed using tools like {@link https://codeandweb.com/texturepacker|TexturePacker},\n * {@link https://renderhjs.net/shoebox/|Shoebox} or {@link https://github.com/krzysztof-o/spritesheet.js|Spritesheet.js}.\n * Default anchor points (see {@link PIXI.Texture#defaultAnchor}) and grouping of animation sprites are currently only\n * supported by TexturePacker.\n *\n * @class\n * @memberof PIXI\n */\nexport default class Spritesheet\n{\n    /**\n     * The maximum number of Textures to build per process.\n     *\n     * @type {number}\n     * @default 1000\n     */\n    static get BATCH_SIZE()\n    {\n        return 1000;\n    }\n\n    /**\n     * @param {PIXI.BaseTexture} baseTexture Reference to the source BaseTexture object.\n     * @param {Object} data - Spritesheet image data.\n     * @param {string} [resolutionFilename] - The filename to consider when determining\n     *        the resolution of the spritesheet. If not provided, the imageUrl will\n     *        be used on the BaseTexture.\n     */\n    constructor(baseTexture, data, resolutionFilename = null)\n    {\n        /**\n         * Reference to ths source texture\n         * @type {PIXI.BaseTexture}\n         */\n        this.baseTexture = baseTexture;\n\n        /**\n         * A map containing all textures of the sprite sheet.\n         * Can be used to create a {@link PIXI.Sprite|Sprite}:\n         * ```js\n         * new PIXI.Sprite(sheet.textures[\"image.png\"]);\n         * ```\n         * @member {Object}\n         */\n        this.textures = {};\n\n        /**\n         * A map containing the textures for each animation.\n         * Can be used to create an {@link PIXI.extras.AnimatedSprite|AnimatedSprite}:\n         * ```js\n         * new PIXI.extras.AnimatedSprite(sheet.animations[\"anim_name\"])\n         * ```\n         * @member {Object}\n         */\n        this.animations = {};\n\n        /**\n         * Reference to the original JSON data.\n         * @type {Object}\n         */\n        this.data = data;\n\n        /**\n         * The resolution of the spritesheet.\n         * @type {number}\n         */\n        this.resolution = this._updateResolution(\n            resolutionFilename || this.baseTexture.imageUrl\n        );\n\n        /**\n         * Map of spritesheet frames.\n         * @type {Object}\n         * @private\n         */\n        this._frames = this.data.frames;\n\n        /**\n         * Collection of frame names.\n         * @type {string[]}\n         * @private\n         */\n        this._frameKeys = Object.keys(this._frames);\n\n        /**\n         * Current batch index being processed.\n         * @type {number}\n         * @private\n         */\n        this._batchIndex = 0;\n\n        /**\n         * Callback when parse is completed.\n         * @type {Function}\n         * @private\n         */\n        this._callback = null;\n    }\n\n    /**\n     * Generate the resolution from the filename or fallback\n     * to the meta.scale field of the JSON data.\n     *\n     * @private\n     * @param {string} resolutionFilename - The filename to use for resolving\n     *        the default resolution.\n     * @return {number} Resolution to use for spritesheet.\n     */\n    _updateResolution(resolutionFilename)\n    {\n        const scale = this.data.meta.scale;\n\n        // Use a defaultValue of `null` to check if a url-based resolution is set\n        let resolution = getResolutionOfUrl(resolutionFilename, null);\n\n        // No resolution found via URL\n        if (resolution === null)\n        {\n            // Use the scale value or default to 1\n            resolution = scale !== undefined ? parseFloat(scale) : 1;\n        }\n\n        // For non-1 resolutions, update baseTexture\n        if (resolution !== 1)\n        {\n            this.baseTexture.resolution = resolution;\n            this.baseTexture.update();\n        }\n\n        return resolution;\n    }\n\n    /**\n     * Parser spritesheet from loaded data. This is done asynchronously\n     * to prevent creating too many Texture within a single process.\n     *\n     * @param {Function} callback - Callback when complete returns\n     *        a map of the Textures for this spritesheet.\n     */\n    parse(callback)\n    {\n        this._batchIndex = 0;\n        this._callback = callback;\n\n        if (this._frameKeys.length <= Spritesheet.BATCH_SIZE)\n        {\n            this._processFrames(0);\n            this._processAnimations();\n            this._parseComplete();\n        }\n        else\n        {\n            this._nextBatch();\n        }\n    }\n\n    /**\n     * Process a batch of frames\n     *\n     * @private\n     * @param {number} initialFrameIndex - The index of frame to start.\n     */\n    _processFrames(initialFrameIndex)\n    {\n        let frameIndex = initialFrameIndex;\n        const maxFrames = Spritesheet.BATCH_SIZE;\n        const sourceScale = this.baseTexture.sourceScale;\n\n        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length)\n        {\n            const i = this._frameKeys[frameIndex];\n            const data = this._frames[i];\n            const rect = data.frame;\n\n            if (rect)\n            {\n                let frame = null;\n                let trim = null;\n                const sourceSize = data.trimmed !== false && data.sourceSize\n                    ? data.sourceSize : data.frame;\n\n                const orig = new Rectangle(\n                    0,\n                    0,\n                    Math.floor(sourceSize.w * sourceScale) / this.resolution,\n                    Math.floor(sourceSize.h * sourceScale) / this.resolution\n                );\n\n                if (data.rotated)\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x * sourceScale) / this.resolution,\n                        Math.floor(rect.y * sourceScale) / this.resolution,\n                        Math.floor(rect.h * sourceScale) / this.resolution,\n                        Math.floor(rect.w * sourceScale) / this.resolution\n                    );\n                }\n                else\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x * sourceScale) / this.resolution,\n                        Math.floor(rect.y * sourceScale) / this.resolution,\n                        Math.floor(rect.w * sourceScale) / this.resolution,\n                        Math.floor(rect.h * sourceScale) / this.resolution\n                    );\n                }\n\n                //  Check to see if the sprite is trimmed\n                if (data.trimmed !== false && data.spriteSourceSize)\n                {\n                    trim = new Rectangle(\n                        Math.floor(data.spriteSourceSize.x * sourceScale) / this.resolution,\n                        Math.floor(data.spriteSourceSize.y * sourceScale) / this.resolution,\n                        Math.floor(rect.w * sourceScale) / this.resolution,\n                        Math.floor(rect.h * sourceScale) / this.resolution\n                    );\n                }\n\n                this.textures[i] = new Texture(\n                    this.baseTexture,\n                    frame,\n                    orig,\n                    trim,\n                    data.rotated ? 2 : 0,\n                    data.anchor\n                );\n\n                // lets also add the frame to pixi's global cache for fromFrame and fromImage functions\n                Texture.addToCache(this.textures[i], i);\n            }\n\n            frameIndex++;\n        }\n    }\n\n    /**\n     * Parse animations config\n     *\n     * @private\n     */\n    _processAnimations()\n    {\n        const animations = this.data.animations || {};\n\n        for (const animName in animations)\n        {\n            this.animations[animName] = [];\n            for (const frameName of animations[animName])\n            {\n                this.animations[animName].push(this.textures[frameName]);\n            }\n        }\n    }\n\n    /**\n     * The parse has completed.\n     *\n     * @private\n     */\n    _parseComplete()\n    {\n        const callback = this._callback;\n\n        this._callback = null;\n        this._batchIndex = 0;\n        callback.call(this, this.textures);\n    }\n\n    /**\n     * Begin the next batch of textures.\n     *\n     * @private\n     */\n    _nextBatch()\n    {\n        this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);\n        this._batchIndex++;\n        setTimeout(() =>\n        {\n            if (this._batchIndex * Spritesheet.BATCH_SIZE < this._frameKeys.length)\n            {\n                this._nextBatch();\n            }\n            else\n            {\n                this._processAnimations();\n                this._parseComplete();\n            }\n        }, 0);\n    }\n\n    /**\n     * Destroy Spritesheet and don't use after this.\n     *\n     * @param {boolean} [destroyBase=false] Whether to destroy the base texture as well\n     */\n    destroy(destroyBase = false)\n    {\n        for (const i in this.textures)\n        {\n            this.textures[i].destroy();\n        }\n        this._frames = null;\n        this._frameKeys = null;\n        this.data = null;\n        this.textures = null;\n        if (destroyBase)\n        {\n            this.baseTexture.destroy();\n        }\n        this.baseTexture = null;\n    }\n}\n"]}