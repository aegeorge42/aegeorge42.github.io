{"version":3,"sources":["../../../src/core/textures/BaseTexture.js"],"names":["BaseTexture","source","scaleMode","resolution","uid","touched","RESOLUTION","width","height","realWidth","realHeight","undefined","SCALE_MODE","hasLoaded","isLoading","origSource","imageType","sourceScale","premultipliedAlpha","imageUrl","isPowerOfTwo","mipmap","MIPMAP_TEXTURES","wrapMode","WRAP_MODE","_glTextures","_enabled","_virtalBoundId","_destroyed","textureCacheIds","loadSource","update","naturalWidth","videoWidth","naturalHeight","videoHeight","_updateDimensions","emit","isPow2","wasLoading","onload","onerror","firstSourceLoaded","src","complete","getContext","_updateImageType","_loadSvgSource","_sourceLoaded","scope","dataUri","mediaType","firstSubType","subType","split","Error","_loadSvgSourceUsingDataUri","_loadSvgSourceUsingXhr","svgString","encoding","atob","data","_loadSvgSourceUsingString","svgXhr","XMLHttpRequest","readyState","DONE","status","response","open","send","svgSize","svgWidth","svgHeight","Math","round","canvas","document","createElement","_pixiId","drawImage","addToCache","destroy","navigator","isCocoonJS","dispose","removeFromCache","updateSourceImage","newSrc","fromImage","crossorigin","baseTexture","image","Image","indexOf","crossOrigin","fromCanvas","origin","from","HTMLImageElement","HTMLCanvasElement","id","push","console","warn","baseTextureFromCache","index","splice","i","length"],"mappings":"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","file":"BaseTexture.js","sourcesContent":["import {\n    uid, getUrlFileExtension, decomposeDataUri, getSvgSize,\n    getResolutionOfUrl, BaseTextureCache, TextureCache,\n} from '../utils';\nimport settings from '../settings';\nimport EventEmitter from 'eventemitter3';\nimport determineCrossOrigin from '../utils/determineCrossOrigin';\nimport bitTwiddle from 'bit-twiddle';\n\n/**\n * A texture stores the information that represents an image. All textures have a base texture.\n *\n * @class\n * @extends EventEmitter\n * @memberof PIXI\n */\nexport default class BaseTexture extends EventEmitter\n{\n    /**\n     * @param {HTMLImageElement|HTMLCanvasElement} [source] - the source object of the texture.\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n     * @param {number} [resolution=1] - The resolution / device pixel ratio of the texture\n     */\n    constructor(source, scaleMode, resolution)\n    {\n        super();\n\n        this.uid = uid();\n\n        this.touched = 0;\n\n        /**\n         * The resolution / device pixel ratio of the texture\n         *\n         * @member {number}\n         * @default 1\n         */\n        this.resolution = resolution || settings.RESOLUTION;\n\n        /**\n         * The width of the base texture set when the image has loaded\n         *\n         * @readonly\n         * @member {number}\n         */\n        this.width = 100;\n\n        /**\n         * The height of the base texture set when the image has loaded\n         *\n         * @readonly\n         * @member {number}\n         */\n        this.height = 100;\n\n        // TODO docs\n        // used to store the actual dimensions of the source\n        /**\n         * Used to store the actual width of the source of this texture\n         *\n         * @readonly\n         * @member {number}\n         */\n        this.realWidth = 100;\n        /**\n         * Used to store the actual height of the source of this texture\n         *\n         * @readonly\n         * @member {number}\n         */\n        this.realHeight = 100;\n\n        /**\n         * The scale mode to apply when scaling this texture\n         *\n         * @member {number}\n         * @default PIXI.settings.SCALE_MODE\n         * @see PIXI.SCALE_MODES\n         */\n        this.scaleMode = scaleMode !== undefined ? scaleMode : settings.SCALE_MODE;\n\n        /**\n         * Set to true once the base texture has successfully loaded.\n         *\n         * This is never true if the underlying source fails to load or has no texture data.\n         *\n         * @readonly\n         * @member {boolean}\n         */\n        this.hasLoaded = false;\n\n        /**\n         * Set to true if the source is currently loading.\n         *\n         * If an Image source is loading the 'loaded' or 'error' event will be\n         * dispatched when the operation ends. An underyling source that is\n         * immediately-available bypasses loading entirely.\n         *\n         * @readonly\n         * @member {boolean}\n         */\n        this.isLoading = false;\n\n        /**\n         * The image source that is used to create the texture.\n         *\n         * TODO: Make this a setter that calls loadSource();\n         *\n         * @readonly\n         * @member {HTMLImageElement|HTMLCanvasElement}\n         */\n        this.source = null; // set in loadSource, if at all\n\n        /**\n         * The image source that is used to create the texture. This is used to\n         * store the original Svg source when it is replaced with a canvas element.\n         *\n         * TODO: Currently not in use but could be used when re-scaling svg.\n         *\n         * @readonly\n         * @member {Image}\n         */\n        this.origSource = null; // set in loadSvg, if at all\n\n        /**\n         * Type of image defined in source, eg. `png` or `svg`\n         *\n         * @readonly\n         * @member {string}\n         */\n        this.imageType = null; // set in updateImageType\n\n        /**\n         * Scale for source image. Used with Svg images to scale them before rasterization.\n         *\n         * @readonly\n         * @member {number}\n         */\n        this.sourceScale = 1.0;\n\n        /**\n         * Controls if RGB channels should be pre-multiplied by Alpha  (WebGL only)\n         * All blend modes, and shaders written for default value. Change it on your own risk.\n         *\n         * @member {boolean}\n         * @default true\n         */\n        this.premultipliedAlpha = true;\n\n        /**\n         * The image url of the texture\n         *\n         * @member {string}\n         */\n        this.imageUrl = null;\n\n        /**\n         * Whether or not the texture is a power of two, try to use power of two textures as much\n         * as you can\n         *\n         * @private\n         * @member {boolean}\n         */\n        this.isPowerOfTwo = false;\n\n        // used for webGL\n\n        /**\n         *\n         * Set this to true if a mipmap of this texture needs to be generated. This value needs\n         * to be set before the texture is used\n         * Also the texture must be a power of two size to work\n         *\n         * @member {boolean}\n         * @see PIXI.MIPMAP_TEXTURES\n         */\n        this.mipmap = settings.MIPMAP_TEXTURES;\n\n        /**\n         *\n         * WebGL Texture wrap mode\n         *\n         * @member {number}\n         * @see PIXI.WRAP_MODES\n         */\n        this.wrapMode = settings.WRAP_MODE;\n\n        /**\n         * A map of renderer IDs to webgl textures\n         *\n         * @private\n         * @member {object<number, WebGLTexture>}\n         */\n        this._glTextures = {};\n\n        this._enabled = 0;\n        this._virtalBoundId = -1;\n\n        /**\n         * If the object has been destroyed via destroy(). If true, it should not be used.\n         *\n         * @member {boolean}\n         * @private\n         * @readonly\n         */\n        this._destroyed = false;\n\n        /**\n         * The ids under which this BaseTexture has been added to the base texture cache. This is\n         * automatically set as long as BaseTexture.addToCache is used, but may not be set if a\n         * BaseTexture is added directly to the BaseTextureCache array.\n         *\n         * @member {string[]}\n         */\n        this.textureCacheIds = [];\n\n        // if no source passed don't try to load\n        if (source)\n        {\n            this.loadSource(source);\n        }\n\n        /**\n         * Fired when a not-immediately-available source finishes loading.\n         *\n         * @protected\n         * @event PIXI.BaseTexture#loaded\n         * @param {PIXI.BaseTexture} baseTexture - Resource loaded.\n         */\n\n        /**\n         * Fired when a not-immediately-available source fails to load.\n         *\n         * @protected\n         * @event PIXI.BaseTexture#error\n         * @param {PIXI.BaseTexture} baseTexture - Resource errored.\n         */\n\n        /**\n         * Fired when BaseTexture is updated.\n         *\n         * @protected\n         * @event PIXI.BaseTexture#update\n         * @param {PIXI.BaseTexture} baseTexture - Instance of texture being updated.\n         */\n\n        /**\n         * Fired when BaseTexture is destroyed.\n         *\n         * @protected\n         * @event PIXI.BaseTexture#dispose\n         * @param {PIXI.BaseTexture} baseTexture - Instance of texture being destroyed.\n         */\n    }\n\n    /**\n     * Updates the texture on all the webgl renderers, this also assumes the src has changed.\n     *\n     * @fires PIXI.BaseTexture#update\n     */\n    update()\n    {\n        // Svg size is handled during load\n        if (this.imageType !== 'svg')\n        {\n            this.realWidth = this.source.naturalWidth || this.source.videoWidth || this.source.width;\n            this.realHeight = this.source.naturalHeight || this.source.videoHeight || this.source.height;\n\n            this._updateDimensions();\n        }\n\n        this.emit('update', this);\n    }\n\n    /**\n     * Update dimensions from real values\n     */\n    _updateDimensions()\n    {\n        this.width = this.realWidth / this.resolution;\n        this.height = this.realHeight / this.resolution;\n\n        this.isPowerOfTwo = bitTwiddle.isPow2(this.realWidth) && bitTwiddle.isPow2(this.realHeight);\n    }\n\n    /**\n     * Load a source.\n     *\n     * If the source is not-immediately-available, such as an image that needs to be\n     * downloaded, then the 'loaded' or 'error' event will be dispatched in the future\n     * and `hasLoaded` will remain false after this call.\n     *\n     * The logic state after calling `loadSource` directly or indirectly (eg. `fromImage`, `new BaseTexture`) is:\n     *\n     *     if (texture.hasLoaded) {\n     *        // texture ready for use\n     *     } else if (texture.isLoading) {\n     *        // listen to 'loaded' and/or 'error' events on texture\n     *     } else {\n     *        // not loading, not going to load UNLESS the source is reloaded\n     *        // (it may still make sense to listen to the events)\n     *     }\n     *\n     * @protected\n     * @param {HTMLImageElement|HTMLCanvasElement} source - the source object of the texture.\n     */\n    loadSource(source)\n    {\n        const wasLoading = this.isLoading;\n\n        this.hasLoaded = false;\n        this.isLoading = false;\n\n        if (wasLoading && this.source)\n        {\n            this.source.onload = null;\n            this.source.onerror = null;\n        }\n\n        const firstSourceLoaded = !this.source;\n\n        this.source = source;\n\n        // Apply source if loaded. Otherwise setup appropriate loading monitors.\n        if (((source.src && source.complete) || source.getContext) && source.width && source.height)\n        {\n            this._updateImageType();\n\n            if (this.imageType === 'svg')\n            {\n                this._loadSvgSource();\n            }\n            else\n            {\n                this._sourceLoaded();\n            }\n\n            if (firstSourceLoaded)\n            {\n                // send loaded event if previous source was null and we have been passed a pre-loaded IMG element\n                this.emit('loaded', this);\n            }\n        }\n        else if (!source.getContext)\n        {\n            // Image fail / not ready\n            this.isLoading = true;\n\n            const scope = this;\n\n            source.onload = () =>\n            {\n                scope._updateImageType();\n                source.onload = null;\n                source.onerror = null;\n\n                if (!scope.isLoading)\n                {\n                    return;\n                }\n\n                scope.isLoading = false;\n                scope._sourceLoaded();\n\n                if (scope.imageType === 'svg')\n                {\n                    scope._loadSvgSource();\n\n                    return;\n                }\n\n                scope.emit('loaded', scope);\n            };\n\n            source.onerror = () =>\n            {\n                source.onload = null;\n                source.onerror = null;\n\n                if (!scope.isLoading)\n                {\n                    return;\n                }\n\n                scope.isLoading = false;\n                scope.emit('error', scope);\n            };\n\n            // Per http://www.w3.org/TR/html5/embedded-content-0.html#the-img-element\n            //   \"The value of `complete` can thus change while a script is executing.\"\n            // So complete needs to be re-checked after the callbacks have been added..\n            // NOTE: complete will be true if the image has no src so best to check if the src is set.\n            if (source.complete && source.src)\n            {\n                // ..and if we're complete now, no need for callbacks\n                source.onload = null;\n                source.onerror = null;\n\n                if (scope.imageType === 'svg')\n                {\n                    scope._loadSvgSource();\n\n                    return;\n                }\n\n                this.isLoading = false;\n\n                if (source.width && source.height)\n                {\n                    this._sourceLoaded();\n\n                    // If any previous subscribers possible\n                    if (wasLoading)\n                    {\n                        this.emit('loaded', this);\n                    }\n                }\n                // If any previous subscribers possible\n                else if (wasLoading)\n                {\n                    this.emit('error', this);\n                }\n            }\n        }\n    }\n\n    /**\n     * Updates type of the source image.\n     */\n    _updateImageType()\n    {\n        if (!this.imageUrl)\n        {\n            return;\n        }\n\n        const dataUri = decomposeDataUri(this.imageUrl);\n        let imageType;\n\n        if (dataUri && dataUri.mediaType === 'image')\n        {\n            // Check for subType validity\n            const firstSubType = dataUri.subType.split('+')[0];\n\n            imageType = getUrlFileExtension(`.${firstSubType}`);\n\n            if (!imageType)\n            {\n                throw new Error('Invalid image type in data URI.');\n            }\n        }\n        else\n        {\n            imageType = getUrlFileExtension(this.imageUrl);\n\n            if (!imageType)\n            {\n                imageType = 'png';\n            }\n        }\n\n        this.imageType = imageType;\n    }\n\n    /**\n     * Checks if `source` is an SVG image and whether it's loaded via a URL or a data URI. Then calls\n     * `_loadSvgSourceUsingDataUri` or `_loadSvgSourceUsingXhr`.\n     */\n    _loadSvgSource()\n    {\n        if (this.imageType !== 'svg')\n        {\n            // Do nothing if source is not svg\n            return;\n        }\n\n        const dataUri = decomposeDataUri(this.imageUrl);\n\n        if (dataUri)\n        {\n            this._loadSvgSourceUsingDataUri(dataUri);\n        }\n        else\n        {\n            // We got an URL, so we need to do an XHR to check the svg size\n            this._loadSvgSourceUsingXhr();\n        }\n    }\n\n    /**\n     * Reads an SVG string from data URI and then calls `_loadSvgSourceUsingString`.\n     *\n     * @param {string} dataUri - The data uri to load from.\n     */\n    _loadSvgSourceUsingDataUri(dataUri)\n    {\n        let svgString;\n\n        if (dataUri.encoding === 'base64')\n        {\n            if (!atob)\n            {\n                throw new Error('Your browser doesn\\'t support base64 conversions.');\n            }\n            svgString = atob(dataUri.data);\n        }\n        else\n        {\n            svgString = dataUri.data;\n        }\n\n        this._loadSvgSourceUsingString(svgString);\n    }\n\n    /**\n     * Loads an SVG string from `imageUrl` using XHR and then calls `_loadSvgSourceUsingString`.\n     */\n    _loadSvgSourceUsingXhr()\n    {\n        const svgXhr = new XMLHttpRequest();\n\n        // This throws error on IE, so SVG Document can't be used\n        // svgXhr.responseType = 'document';\n\n        // This is not needed since we load the svg as string (breaks IE too)\n        // but overrideMimeType() can be used to force the response to be parsed as XML\n        // svgXhr.overrideMimeType('image/svg+xml');\n\n        svgXhr.onload = () =>\n        {\n            if (svgXhr.readyState !== svgXhr.DONE || svgXhr.status !== 200)\n            {\n                throw new Error('Failed to load SVG using XHR.');\n            }\n\n            this._loadSvgSourceUsingString(svgXhr.response);\n        };\n\n        svgXhr.onerror = () => this.emit('error', this);\n\n        svgXhr.open('GET', this.imageUrl, true);\n        svgXhr.send();\n    }\n\n    /**\n     * Loads texture using an SVG string. The original SVG Image is stored as `origSource` and the\n     * created canvas is the new `source`. The SVG is scaled using `sourceScale`. Called by\n     * `_loadSvgSourceUsingXhr` or `_loadSvgSourceUsingDataUri`.\n     *\n     * @param  {string} svgString SVG source as string\n     *\n     * @fires PIXI.BaseTexture#loaded\n     */\n    _loadSvgSourceUsingString(svgString)\n    {\n        const svgSize = getSvgSize(svgString);\n\n        const svgWidth = svgSize.width;\n        const svgHeight = svgSize.height;\n\n        if (!svgWidth || !svgHeight)\n        {\n            throw new Error('The SVG image must have width and height defined (in pixels), canvas API needs them.');\n        }\n\n        // Scale realWidth and realHeight\n        this.realWidth = Math.round(svgWidth * this.sourceScale);\n        this.realHeight = Math.round(svgHeight * this.sourceScale);\n\n        this._updateDimensions();\n\n        // Create a canvas element\n        const canvas = document.createElement('canvas');\n\n        canvas.width = this.realWidth;\n        canvas.height = this.realHeight;\n        canvas._pixiId = `canvas_${uid()}`;\n\n        // Draw the Svg to the canvas\n        canvas\n            .getContext('2d')\n            .drawImage(this.source, 0, 0, svgWidth, svgHeight, 0, 0, this.realWidth, this.realHeight);\n\n        // Replace the original source image with the canvas\n        this.origSource = this.source;\n        this.source = canvas;\n\n        // Add also the canvas in cache (destroy clears by `imageUrl` and `source._pixiId`)\n        BaseTexture.addToCache(this, canvas._pixiId);\n\n        this.isLoading = false;\n        this._sourceLoaded();\n        this.emit('loaded', this);\n    }\n\n    /**\n     * Used internally to update the width, height, and some other tracking vars once\n     * a source has successfully loaded.\n     *\n     * @private\n     */\n    _sourceLoaded()\n    {\n        this.hasLoaded = true;\n        this.update();\n    }\n\n    /**\n     * Destroys this base texture\n     *\n     */\n    destroy()\n    {\n        if (this.imageUrl)\n        {\n            delete TextureCache[this.imageUrl];\n\n            this.imageUrl = null;\n\n            if (!navigator.isCocoonJS)\n            {\n                this.source.src = '';\n            }\n        }\n\n        this.source = null;\n\n        this.dispose();\n\n        BaseTexture.removeFromCache(this);\n        this.textureCacheIds = null;\n\n        this._destroyed = true;\n    }\n\n    /**\n     * Frees the texture from WebGL memory without destroying this texture object.\n     * This means you can still use the texture later which will upload it to GPU\n     * memory again.\n     *\n     * @fires PIXI.BaseTexture#dispose\n     */\n    dispose()\n    {\n        this.emit('dispose', this);\n    }\n\n    /**\n     * Changes the source image of the texture.\n     * The original source must be an Image element.\n     *\n     * @param {string} newSrc - the path of the image\n     */\n    updateSourceImage(newSrc)\n    {\n        this.source.src = newSrc;\n\n        this.loadSource(this.source);\n    }\n\n    /**\n     * Helper function that creates a base texture from the given image url.\n     * If the image is not in the base texture cache it will be created and loaded.\n     *\n     * @static\n     * @param {string} imageUrl - The image url of the texture\n     * @param {boolean} [crossorigin=(auto)] - Should use anonymous CORS? Defaults to true if the URL is not a data-URI.\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n     * @param {number} [sourceScale=(auto)] - Scale for the original image, used with Svg images.\n     * @return {PIXI.BaseTexture} The new base texture.\n     */\n    static fromImage(imageUrl, crossorigin, scaleMode, sourceScale)\n    {\n        let baseTexture = BaseTextureCache[imageUrl];\n\n        if (!baseTexture)\n        {\n            // new Image() breaks tex loading in some versions of Chrome.\n            // See https://code.google.com/p/chromium/issues/detail?id=238071\n            const image = new Image();// document.createElement('img');\n\n            if (crossorigin === undefined && imageUrl.indexOf('data:') !== 0)\n            {\n                image.crossOrigin = determineCrossOrigin(imageUrl);\n            }\n            else if (crossorigin)\n            {\n                image.crossOrigin = typeof crossorigin === 'string' ? crossorigin : 'anonymous';\n            }\n\n            baseTexture = new BaseTexture(image, scaleMode);\n            baseTexture.imageUrl = imageUrl;\n\n            if (sourceScale)\n            {\n                baseTexture.sourceScale = sourceScale;\n            }\n\n            // if there is an @2x at the end of the url we are going to assume its a highres image\n            baseTexture.resolution = getResolutionOfUrl(imageUrl);\n\n            image.src = imageUrl; // Setting this triggers load\n\n            BaseTexture.addToCache(baseTexture, imageUrl);\n        }\n\n        return baseTexture;\n    }\n\n    /**\n     * Helper function that creates a base texture from the given canvas element.\n     *\n     * @static\n     * @param {HTMLCanvasElement} canvas - The canvas element source of the texture\n     * @param {number} scaleMode - See {@link PIXI.SCALE_MODES} for possible values\n     * @param {string} [origin='canvas'] - A string origin of who created the base texture\n     * @return {PIXI.BaseTexture} The new base texture.\n     */\n    static fromCanvas(canvas, scaleMode, origin = 'canvas')\n    {\n        if (!canvas._pixiId)\n        {\n            canvas._pixiId = `${origin}_${uid()}`;\n        }\n\n        let baseTexture = BaseTextureCache[canvas._pixiId];\n\n        if (!baseTexture)\n        {\n            baseTexture = new BaseTexture(canvas, scaleMode);\n            BaseTexture.addToCache(baseTexture, canvas._pixiId);\n        }\n\n        return baseTexture;\n    }\n\n    /**\n     * Helper function that creates a base texture based on the source you provide.\n     * The source can be - image url, image element, canvas element. If the\n     * source is an image url or an image element and not in the base texture\n     * cache, it will be created and loaded.\n     *\n     * @static\n     * @param {string|HTMLImageElement|HTMLCanvasElement} source - The source to create base texture from.\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n     * @param {number} [sourceScale=(auto)] - Scale for the original image, used with Svg images.\n     * @return {PIXI.BaseTexture} The new base texture.\n     */\n    static from(source, scaleMode, sourceScale)\n    {\n        if (typeof source === 'string')\n        {\n            return BaseTexture.fromImage(source, undefined, scaleMode, sourceScale);\n        }\n        else if (source instanceof HTMLImageElement)\n        {\n            const imageUrl = source.src;\n            let baseTexture = BaseTextureCache[imageUrl];\n\n            if (!baseTexture)\n            {\n                baseTexture = new BaseTexture(source, scaleMode);\n                baseTexture.imageUrl = imageUrl;\n\n                if (sourceScale)\n                {\n                    baseTexture.sourceScale = sourceScale;\n                }\n\n                // if there is an @2x at the end of the url we are going to assume its a highres image\n                baseTexture.resolution = getResolutionOfUrl(imageUrl);\n\n                BaseTexture.addToCache(baseTexture, imageUrl);\n            }\n\n            return baseTexture;\n        }\n        else if (source instanceof HTMLCanvasElement)\n        {\n            return BaseTexture.fromCanvas(source, scaleMode);\n        }\n\n        // lets assume its a base texture!\n        return source;\n    }\n\n    /**\n     * Adds a BaseTexture to the global BaseTextureCache. This cache is shared across the whole PIXI object.\n     *\n     * @static\n     * @param {PIXI.BaseTexture} baseTexture - The BaseTexture to add to the cache.\n     * @param {string} id - The id that the BaseTexture will be stored against.\n     */\n    static addToCache(baseTexture, id)\n    {\n        if (id)\n        {\n            if (baseTexture.textureCacheIds.indexOf(id) === -1)\n            {\n                baseTexture.textureCacheIds.push(id);\n            }\n\n            // @if DEBUG\n            /* eslint-disable no-console */\n            if (BaseTextureCache[id])\n            {\n                console.warn(`BaseTexture added to the cache with an id [${id}] that already had an entry`);\n            }\n            /* eslint-enable no-console */\n            // @endif\n\n            BaseTextureCache[id] = baseTexture;\n        }\n    }\n\n    /**\n     * Remove a BaseTexture from the global BaseTextureCache.\n     *\n     * @static\n     * @param {string|PIXI.BaseTexture} baseTexture - id of a BaseTexture to be removed, or a BaseTexture instance itself.\n     * @return {PIXI.BaseTexture|null} The BaseTexture that was removed.\n     */\n    static removeFromCache(baseTexture)\n    {\n        if (typeof baseTexture === 'string')\n        {\n            const baseTextureFromCache = BaseTextureCache[baseTexture];\n\n            if (baseTextureFromCache)\n            {\n                const index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);\n\n                if (index > -1)\n                {\n                    baseTextureFromCache.textureCacheIds.splice(index, 1);\n                }\n\n                delete BaseTextureCache[baseTexture];\n\n                return baseTextureFromCache;\n            }\n        }\n        else if (baseTexture && baseTexture.textureCacheIds)\n        {\n            for (let i = 0; i < baseTexture.textureCacheIds.length; ++i)\n            {\n                delete BaseTextureCache[baseTexture.textureCacheIds[i]];\n            }\n\n            baseTexture.textureCacheIds.length = 0;\n\n            return baseTexture;\n        }\n\n        return null;\n    }\n}\n"]}