{"version":3,"sources":["../../../src/core/textures/Texture.js"],"names":["Texture","baseTexture","frame","orig","trim","rotate","anchor","noFrame","_frame","valid","requiresUpdate","_uvs","_rotate","Number","Error","hasLoaded","width","height","on","onBaseTextureUpdated","once","onBaseTextureLoaded","defaultAnchor","x","y","_updateID","transform","textureCacheIds","update","emit","destroy","destroyBase","imageUrl","removeFromCache","off","clone","_updateUvs","set","fromImage","crossorigin","scaleMode","sourceScale","texture","addToCache","fromFrame","frameId","fromCanvas","canvas","origin","fromVideo","video","autoPlay","fromVideoUrl","videoUrl","fromUrl","from","source","isVideo","match","HTMLImageElement","HTMLCanvasElement","SCALE_MODE","HTMLVideoElement","fromLoader","name","undefined","id","indexOf","push","console","warn","textureFromCache","index","splice","i","length","xNotFit","yNotFit","relationship","errorX","errorY","createWhiteTexture","document","createElement","context","getContext","fillStyle","fillRect","removeAllHandlers","tex","_emptyDestroy","_emptyOn","_emptyOnce","_emptyEmit","EMPTY","WHITE"],"mappings":"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","file":"Texture.js","sourcesContent":["import BaseTexture from './BaseTexture';\nimport VideoBaseTexture from './VideoBaseTexture';\nimport TextureUvs from './TextureUvs';\nimport EventEmitter from 'eventemitter3';\nimport { Rectangle, Point } from '../math';\nimport { TextureCache, getResolutionOfUrl } from '../utils';\nimport settings from '../settings';\n\n/**\n * A texture stores the information that represents an image or part of an image. It cannot be added\n * to the display list directly. Instead use it as the texture for a Sprite. If no frame is provided\n * then the whole image is used.\n *\n * You can directly create a texture from an image and then reuse it multiple times like this :\n *\n * ```js\n * let texture = PIXI.Texture.fromImage('assets/image.png');\n * let sprite1 = new PIXI.Sprite(texture);\n * let sprite2 = new PIXI.Sprite(texture);\n * ```\n *\n * Textures made from SVGs, loaded or not, cannot be used before the file finishes processing.\n * You can check for this by checking the sprite's _textureID property.\n * ```js\n * var texture = PIXI.Texture.fromImage('assets/image.svg');\n * var sprite1 = new PIXI.Sprite(texture);\n * //sprite1._textureID should not be undefined if the texture has finished processing the SVG file\n * ```\n * You can use a ticker or rAF to ensure your sprites load the finished textures after processing. See issue #3068.\n *\n * @class\n * @extends EventEmitter\n * @memberof PIXI\n */\nexport default class Texture extends EventEmitter\n{\n    /**\n     * @param {PIXI.BaseTexture} baseTexture - The base texture source to create the texture from\n     * @param {PIXI.Rectangle} [frame] - The rectangle frame of the texture to show\n     * @param {PIXI.Rectangle} [orig] - The area of original texture\n     * @param {PIXI.Rectangle} [trim] - Trimmed rectangle of original texture\n     * @param {number} [rotate] - indicates how the texture was rotated by texture packer. See {@link PIXI.GroupD8}\n     * @param {PIXI.Point} [anchor] - Default anchor point used for sprite placement / rotation\n     */\n    constructor(baseTexture, frame, orig, trim, rotate, anchor)\n    {\n        super();\n\n        /**\n         * Does this Texture have any frame data assigned to it?\n         *\n         * @member {boolean}\n         */\n        this.noFrame = false;\n\n        if (!frame)\n        {\n            this.noFrame = true;\n            frame = new Rectangle(0, 0, 1, 1);\n        }\n\n        if (baseTexture instanceof Texture)\n        {\n            baseTexture = baseTexture.baseTexture;\n        }\n\n        /**\n         * The base texture that this texture uses.\n         *\n         * @member {PIXI.BaseTexture}\n         */\n        this.baseTexture = baseTexture;\n\n        /**\n         * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n         * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n         *\n         * @member {PIXI.Rectangle}\n         */\n        this._frame = frame;\n\n        /**\n         * This is the trimmed area of original texture, before it was put in atlas\n         * Please call `_updateUvs()` after you change coordinates of `trim` manually.\n         *\n         * @member {PIXI.Rectangle}\n         */\n        this.trim = trim;\n\n        /**\n         * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.\n         *\n         * @member {boolean}\n         */\n        this.valid = false;\n\n        /**\n         * This will let a renderer know that a texture has been updated (used mainly for webGL uv updates)\n         *\n         * @member {boolean}\n         */\n        this.requiresUpdate = false;\n\n        /**\n         * The WebGL UV data cache.\n         *\n         * @member {PIXI.TextureUvs}\n         * @private\n         */\n        this._uvs = null;\n\n        /**\n         * This is the area of original texture, before it was put in atlas\n         *\n         * @member {PIXI.Rectangle}\n         */\n        this.orig = orig || frame;// new Rectangle(0, 0, 1, 1);\n\n        this._rotate = Number(rotate || 0);\n\n        if (rotate === true)\n        {\n            // this is old texturepacker legacy, some games/libraries are passing \"true\" for rotated textures\n            this._rotate = 2;\n        }\n        else if (this._rotate % 2 !== 0)\n        {\n            throw new Error('attempt to use diamond-shaped UVs. If you are sure, set rotation manually');\n        }\n\n        if (baseTexture.hasLoaded)\n        {\n            if (this.noFrame)\n            {\n                frame = new Rectangle(0, 0, baseTexture.width, baseTexture.height);\n\n                // if there is no frame we should monitor for any base texture changes..\n                baseTexture.on('update', this.onBaseTextureUpdated, this);\n            }\n            this.frame = frame;\n        }\n        else\n        {\n            baseTexture.once('loaded', this.onBaseTextureLoaded, this);\n        }\n\n        /**\n         * Anchor point that is used as default if sprite is created with this texture.\n         * Changing the `defaultAnchor` at a later point of time will not update Sprite's anchor point.\n         * @member {PIXI.Point}\n         * @default {0,0}\n         */\n        this.defaultAnchor = anchor ? new Point(anchor.x, anchor.y) : new Point(0, 0);\n\n        /**\n         * Fired when the texture is updated. This happens if the frame or the baseTexture is updated.\n         *\n         * @event PIXI.Texture#update\n         * @protected\n         * @param {PIXI.Texture} texture - Instance of texture being updated.\n         */\n\n        this._updateID = 0;\n\n        /**\n         * Contains data for uvs. May contain clamp settings and some matrices.\n         * Its a bit heavy, so by default that object is not created.\n         * @member {PIXI.TextureMatrix}\n         * @default null\n         */\n        this.transform = null;\n\n        /**\n         * The ids under which this Texture has been added to the texture cache. This is\n         * automatically set as long as Texture.addToCache is used, but may not be set if a\n         * Texture is added directly to the TextureCache array.\n         *\n         * @member {string[]}\n         */\n        this.textureCacheIds = [];\n    }\n\n    /**\n     * Updates this texture on the gpu.\n     *\n     */\n    update()\n    {\n        this.baseTexture.update();\n    }\n\n    /**\n     * Called when the base texture is loaded\n     *\n     * @private\n     * @param {PIXI.BaseTexture} baseTexture - The base texture.\n     */\n    onBaseTextureLoaded(baseTexture)\n    {\n        this._updateID++;\n\n        // TODO this code looks confusing.. boo to abusing getters and setters!\n        if (this.noFrame)\n        {\n            this.frame = new Rectangle(0, 0, baseTexture.width, baseTexture.height);\n        }\n        else\n        {\n            this.frame = this._frame;\n        }\n\n        this.baseTexture.on('update', this.onBaseTextureUpdated, this);\n        this.emit('update', this);\n    }\n\n    /**\n     * Called when the base texture is updated\n     *\n     * @private\n     * @param {PIXI.BaseTexture} baseTexture - The base texture.\n     */\n    onBaseTextureUpdated(baseTexture)\n    {\n        this._updateID++;\n\n        this._frame.width = baseTexture.width;\n        this._frame.height = baseTexture.height;\n\n        this.emit('update', this);\n    }\n\n    /**\n     * Destroys this texture\n     *\n     * @param {boolean} [destroyBase=false] Whether to destroy the base texture as well\n     */\n    destroy(destroyBase)\n    {\n        if (this.baseTexture)\n        {\n            if (destroyBase)\n            {\n                // delete the texture if it exists in the texture cache..\n                // this only needs to be removed if the base texture is actually destroyed too..\n                if (TextureCache[this.baseTexture.imageUrl])\n                {\n                    Texture.removeFromCache(this.baseTexture.imageUrl);\n                }\n\n                this.baseTexture.destroy();\n            }\n\n            this.baseTexture.off('update', this.onBaseTextureUpdated, this);\n            this.baseTexture.off('loaded', this.onBaseTextureLoaded, this);\n\n            this.baseTexture = null;\n        }\n\n        this._frame = null;\n        this._uvs = null;\n        this.trim = null;\n        this.orig = null;\n\n        this.valid = false;\n\n        Texture.removeFromCache(this);\n        this.textureCacheIds = null;\n    }\n\n    /**\n     * Creates a new texture object that acts the same as this one.\n     *\n     * @return {PIXI.Texture} The new texture\n     */\n    clone()\n    {\n        return new Texture(this.baseTexture, this.frame, this.orig, this.trim, this.rotate, this.defaultAnchor);\n    }\n\n    /**\n     * Updates the internal WebGL UV cache. Use it after you change `frame` or `trim` of the texture.\n     */\n    _updateUvs()\n    {\n        if (!this._uvs)\n        {\n            this._uvs = new TextureUvs();\n        }\n\n        this._uvs.set(this._frame, this.baseTexture, this.rotate);\n\n        this._updateID++;\n    }\n\n    /**\n     * Helper function that creates a Texture object from the given image url.\n     * If the image is not in the texture cache it will be  created and loaded.\n     *\n     * @static\n     * @param {string} imageUrl - The image url of the texture\n     * @param {boolean} [crossorigin] - Whether requests should be treated as crossorigin\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n     * @param {number} [sourceScale=(auto)] - Scale for the original image, used with SVG images.\n     * @return {PIXI.Texture} The newly created texture\n     */\n    static fromImage(imageUrl, crossorigin, scaleMode, sourceScale)\n    {\n        let texture = TextureCache[imageUrl];\n\n        if (!texture)\n        {\n            texture = new Texture(BaseTexture.fromImage(imageUrl, crossorigin, scaleMode, sourceScale));\n            Texture.addToCache(texture, imageUrl);\n        }\n\n        return texture;\n    }\n\n    /**\n     * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId\n     * The frame ids are created when a Texture packer file has been loaded\n     *\n     * @static\n     * @param {string} frameId - The frame Id of the texture in the cache\n     * @return {PIXI.Texture} The newly created texture\n     */\n    static fromFrame(frameId)\n    {\n        const texture = TextureCache[frameId];\n\n        if (!texture)\n        {\n            throw new Error(`The frameId \"${frameId}\" does not exist in the texture cache`);\n        }\n\n        return texture;\n    }\n\n    /**\n     * Helper function that creates a new Texture based on the given canvas element.\n     *\n     * @static\n     * @param {HTMLCanvasElement} canvas - The canvas element source of the texture\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n     * @param {string} [origin='canvas'] - A string origin of who created the base texture\n     * @return {PIXI.Texture} The newly created texture\n     */\n    static fromCanvas(canvas, scaleMode, origin = 'canvas')\n    {\n        return new Texture(BaseTexture.fromCanvas(canvas, scaleMode, origin));\n    }\n\n    /**\n     * Helper function that creates a new Texture based on the given video element.\n     *\n     * @static\n     * @param {HTMLVideoElement|string} video - The URL or actual element of the video\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n     * @param {boolean} [crossorigin=(auto)] - Should use anonymous CORS? Defaults to true if the URL is not a data-URI.\n     * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded\n     * @return {PIXI.Texture} The newly created texture\n     */\n    static fromVideo(video, scaleMode, crossorigin, autoPlay)\n    {\n        if (typeof video === 'string')\n        {\n            return Texture.fromVideoUrl(video, scaleMode, crossorigin, autoPlay);\n        }\n\n        return new Texture(VideoBaseTexture.fromVideo(video, scaleMode, autoPlay));\n    }\n\n    /**\n     * Helper function that creates a new Texture based on the video url.\n     *\n     * @static\n     * @param {string} videoUrl - URL of the video\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n     * @param {boolean} [crossorigin=(auto)] - Should use anonymous CORS? Defaults to true if the URL is not a data-URI.\n     * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded\n     * @return {PIXI.Texture} The newly created texture\n     */\n    static fromVideoUrl(videoUrl, scaleMode, crossorigin, autoPlay)\n    {\n        return new Texture(VideoBaseTexture.fromUrl(videoUrl, scaleMode, crossorigin, autoPlay));\n    }\n\n    /**\n     * Helper function that creates a new Texture based on the source you provide.\n     * The source can be - frame id, image url, video url, canvas element, video element, base texture\n     *\n     * @static\n     * @param {number|string|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|PIXI.BaseTexture}\n     *        source - Source to create texture from\n     * @return {PIXI.Texture} The newly created texture\n     */\n    static from(source)\n    {\n        // TODO auto detect cross origin..\n        // TODO pass in scale mode?\n        if (typeof source === 'string')\n        {\n            const texture = TextureCache[source];\n\n            if (!texture)\n            {\n                // check if its a video..\n                const isVideo = source.match(/\\.(mp4|webm|ogg|h264|avi|mov)$/) !== null;\n\n                if (isVideo)\n                {\n                    return Texture.fromVideoUrl(source);\n                }\n\n                return Texture.fromImage(source);\n            }\n\n            return texture;\n        }\n        else if (source instanceof HTMLImageElement)\n        {\n            return new Texture(BaseTexture.from(source));\n        }\n        else if (source instanceof HTMLCanvasElement)\n        {\n            return Texture.fromCanvas(source, settings.SCALE_MODE, 'HTMLCanvasElement');\n        }\n        else if (source instanceof HTMLVideoElement)\n        {\n            return Texture.fromVideo(source);\n        }\n        else if (source instanceof BaseTexture)\n        {\n            return new Texture(source);\n        }\n\n        // lets assume its a texture!\n        return source;\n    }\n\n    /**\n     * Create a texture from a source and add to the cache.\n     *\n     * @static\n     * @param {HTMLImageElement|HTMLCanvasElement} source - The input source.\n     * @param {String} imageUrl - File name of texture, for cache and resolving resolution.\n     * @param {String} [name] - Human readible name for the texture cache. If no name is\n     *        specified, only `imageUrl` will be used as the cache ID.\n     * @return {PIXI.Texture} Output texture\n     */\n    static fromLoader(source, imageUrl, name)\n    {\n        const baseTexture = new BaseTexture(source, undefined, getResolutionOfUrl(imageUrl));\n        const texture = new Texture(baseTexture);\n\n        baseTexture.imageUrl = imageUrl;\n\n        // No name, use imageUrl instead\n        if (!name)\n        {\n            name = imageUrl;\n        }\n\n        // lets also add the frame to pixi's global cache for fromFrame and fromImage fucntions\n        BaseTexture.addToCache(texture.baseTexture, name);\n        Texture.addToCache(texture, name);\n\n        // also add references by url if they are different.\n        if (name !== imageUrl)\n        {\n            BaseTexture.addToCache(texture.baseTexture, imageUrl);\n            Texture.addToCache(texture, imageUrl);\n        }\n\n        return texture;\n    }\n\n    /**\n     * Adds a Texture to the global TextureCache. This cache is shared across the whole PIXI object.\n     *\n     * @static\n     * @param {PIXI.Texture} texture - The Texture to add to the cache.\n     * @param {string} id - The id that the Texture will be stored against.\n     */\n    static addToCache(texture, id)\n    {\n        if (id)\n        {\n            if (texture.textureCacheIds.indexOf(id) === -1)\n            {\n                texture.textureCacheIds.push(id);\n            }\n\n            // @if DEBUG\n            /* eslint-disable no-console */\n            if (TextureCache[id])\n            {\n                console.warn(`Texture added to the cache with an id [${id}] that already had an entry`);\n            }\n            /* eslint-enable no-console */\n            // @endif\n\n            TextureCache[id] = texture;\n        }\n    }\n\n    /**\n     * Remove a Texture from the global TextureCache.\n     *\n     * @static\n     * @param {string|PIXI.Texture} texture - id of a Texture to be removed, or a Texture instance itself\n     * @return {PIXI.Texture|null} The Texture that was removed\n     */\n    static removeFromCache(texture)\n    {\n        if (typeof texture === 'string')\n        {\n            const textureFromCache = TextureCache[texture];\n\n            if (textureFromCache)\n            {\n                const index = textureFromCache.textureCacheIds.indexOf(texture);\n\n                if (index > -1)\n                {\n                    textureFromCache.textureCacheIds.splice(index, 1);\n                }\n\n                delete TextureCache[texture];\n\n                return textureFromCache;\n            }\n        }\n        else if (texture && texture.textureCacheIds)\n        {\n            for (let i = 0; i < texture.textureCacheIds.length; ++i)\n            {\n                // Check that texture matches the one being passed in before deleting it from the cache.\n                if (TextureCache[texture.textureCacheIds[i]] === texture)\n                {\n                    delete TextureCache[texture.textureCacheIds[i]];\n                }\n            }\n\n            texture.textureCacheIds.length = 0;\n\n            return texture;\n        }\n\n        return null;\n    }\n\n    /**\n     * The frame specifies the region of the base texture that this texture uses.\n     * Please call `_updateUvs()` after you change coordinates of `frame` manually.\n     *\n     * @member {PIXI.Rectangle}\n     */\n    get frame()\n    {\n        return this._frame;\n    }\n\n    set frame(frame) // eslint-disable-line require-jsdoc\n    {\n        this._frame = frame;\n\n        this.noFrame = false;\n\n        const { x, y, width, height } = frame;\n        const xNotFit = x + width > this.baseTexture.width;\n        const yNotFit = y + height > this.baseTexture.height;\n\n        if (xNotFit || yNotFit)\n        {\n            const relationship = xNotFit && yNotFit ? 'and' : 'or';\n            const errorX = `X: ${x} + ${width} = ${x + width} > ${this.baseTexture.width}`;\n            const errorY = `Y: ${y} + ${height} = ${y + height} > ${this.baseTexture.height}`;\n\n            throw new Error('Texture Error: frame does not fit inside the base Texture dimensions: '\n                + `${errorX} ${relationship} ${errorY}`);\n        }\n\n        // this.valid = width && height && this.baseTexture.source && this.baseTexture.hasLoaded;\n        this.valid = width && height && this.baseTexture.hasLoaded;\n\n        if (!this.trim && !this.rotate)\n        {\n            this.orig = frame;\n        }\n\n        if (this.valid)\n        {\n            this._updateUvs();\n        }\n    }\n\n    /**\n     * Indicates whether the texture is rotated inside the atlas\n     * set to 2 to compensate for texture packer rotation\n     * set to 6 to compensate for spine packer rotation\n     * can be used to rotate or mirror sprites\n     * See {@link PIXI.GroupD8} for explanation\n     *\n     * @member {number}\n     */\n    get rotate()\n    {\n        return this._rotate;\n    }\n\n    set rotate(rotate) // eslint-disable-line require-jsdoc\n    {\n        this._rotate = rotate;\n        if (this.valid)\n        {\n            this._updateUvs();\n        }\n    }\n\n    /**\n     * The width of the Texture in pixels.\n     *\n     * @member {number}\n     */\n    get width()\n    {\n        return this.orig.width;\n    }\n\n    /**\n     * The height of the Texture in pixels.\n     *\n     * @member {number}\n     */\n    get height()\n    {\n        return this.orig.height;\n    }\n}\n\nfunction createWhiteTexture()\n{\n    const canvas = document.createElement('canvas');\n\n    canvas.width = 10;\n    canvas.height = 10;\n\n    const context = canvas.getContext('2d');\n\n    context.fillStyle = 'white';\n    context.fillRect(0, 0, 10, 10);\n\n    return new Texture(new BaseTexture(canvas));\n}\n\nfunction removeAllHandlers(tex)\n{\n    tex.destroy = function _emptyDestroy() { /* empty */ };\n    tex.on = function _emptyOn() { /* empty */ };\n    tex.once = function _emptyOnce() { /* empty */ };\n    tex.emit = function _emptyEmit() { /* empty */ };\n}\n\n/**\n * An empty texture, used often to not have to create multiple empty textures.\n * Can not be destroyed.\n *\n * @static\n * @constant\n */\nTexture.EMPTY = new Texture(new BaseTexture());\nremoveAllHandlers(Texture.EMPTY);\nremoveAllHandlers(Texture.EMPTY.baseTexture);\n\n/**\n * A white texture of 10x10 size, used for graphics and other things\n * Can not be destroyed.\n *\n * @static\n * @constant\n */\nTexture.WHITE = createWhiteTexture();\nremoveAllHandlers(Texture.WHITE);\nremoveAllHandlers(Texture.WHITE.baseTexture);\n"]}