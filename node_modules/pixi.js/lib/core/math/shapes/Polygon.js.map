{"version":3,"sources":["../../../../src/core/math/shapes/Polygon.js"],"names":["Polygon","points","Array","isArray","p","i","il","length","push","x","y","closed","type","POLY","clone","slice","close","contains","inside","j","xi","yi","xj","yj","intersect"],"mappings":";;;;AAAA;;;;AACA;;;;;;AAEA;;;;IAIqBA,O;AAEjB;;;;;;;AAOA,uBACA;AAAA,0CADeC,MACf;AADeA,kBACf;AAAA;;AAAA;;AACI,YAAIC,MAAMC,OAAN,CAAcF,OAAO,CAAP,CAAd,CAAJ,EACA;AACIA,qBAASA,OAAO,CAAP,CAAT;AACH;;AAED;AACA,YAAIA,OAAO,CAAP,4BAAJ,EACA;AACI,gBAAMG,IAAI,EAAV;;AAEA,iBAAK,IAAIC,IAAI,CAAR,EAAWC,KAAKL,OAAOM,MAA5B,EAAoCF,IAAIC,EAAxC,EAA4CD,GAA5C,EACA;AACID,kBAAEI,IAAF,CAAOP,OAAOI,CAAP,EAAUI,CAAjB,EAAoBR,OAAOI,CAAP,EAAUK,CAA9B;AACH;;AAEDT,qBAASG,CAAT;AACH;;AAED,aAAKO,MAAL,GAAc,IAAd;;AAEA;;;;;AAKA,aAAKV,MAAL,GAAcA,MAAd;;AAEA;;;;;;;;AAQA,aAAKW,IAAL,GAAY,cAAOC,IAAnB;AACH;;AAED;;;;;;;sBAKAC,K,oBACA;AACI,eAAO,IAAId,OAAJ,CAAY,KAAKC,MAAL,CAAYc,KAAZ,EAAZ,CAAP;AACH,K;;AAED;;;;;;sBAIAC,K,oBACA;AACI,YAAMf,SAAS,KAAKA,MAApB;;AAEA;AACA,YAAIA,OAAO,CAAP,MAAcA,OAAOA,OAAOM,MAAP,GAAgB,CAAvB,CAAd,IAA2CN,OAAO,CAAP,MAAcA,OAAOA,OAAOM,MAAP,GAAgB,CAAvB,CAA7D,EACA;AACIN,mBAAOO,IAAP,CAAYP,OAAO,CAAP,CAAZ,EAAuBA,OAAO,CAAP,CAAvB;AACH;AACJ,K;;AAED;;;;;;;;;sBAOAgB,Q,qBAASR,C,EAAGC,C,EACZ;AACI,YAAIQ,SAAS,KAAb;;AAEA;AACA;AACA,YAAMX,SAAS,KAAKN,MAAL,CAAYM,MAAZ,GAAqB,CAApC;;AAEA,aAAK,IAAIF,IAAI,CAAR,EAAWc,IAAIZ,SAAS,CAA7B,EAAgCF,IAAIE,MAApC,EAA4CY,IAAId,GAAhD,EACA;AACI,gBAAMe,KAAK,KAAKnB,MAAL,CAAYI,IAAI,CAAhB,CAAX;AACA,gBAAMgB,KAAK,KAAKpB,MAAL,CAAaI,IAAI,CAAL,GAAU,CAAtB,CAAX;AACA,gBAAMiB,KAAK,KAAKrB,MAAL,CAAYkB,IAAI,CAAhB,CAAX;AACA,gBAAMI,KAAK,KAAKtB,MAAL,CAAakB,IAAI,CAAL,GAAU,CAAtB,CAAX;AACA,gBAAMK,YAAcH,KAAKX,CAAN,KAAca,KAAKb,CAApB,IAA4BD,IAAK,CAACa,KAAKF,EAAN,KAAa,CAACV,IAAIW,EAAL,KAAYE,KAAKF,EAAjB,CAAb,CAAD,GAAuCD,EAAzF;;AAEA,gBAAII,SAAJ,EACA;AACIN,yBAAS,CAACA,MAAV;AACH;AACJ;;AAED,eAAOA,MAAP;AACH,K;;;;;kBAxGgBlB,O","file":"Polygon.js","sourcesContent":["import Point from '../Point';\nimport { SHAPES } from '../../const';\n\n/**\n * @class\n * @memberof PIXI\n */\nexport default class Polygon\n{\n    /**\n     * @param {PIXI.Point[]|number[]} points - This can be an array of Points\n     *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n     *  the arguments passed can be all the points of the polygon e.g.\n     *  `new PIXI.Polygon(new PIXI.Point(), new PIXI.Point(), ...)`, or the arguments passed can be flat\n     *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n     */\n    constructor(...points)\n    {\n        if (Array.isArray(points[0]))\n        {\n            points = points[0];\n        }\n\n        // if this is an array of points, convert it to a flat array of numbers\n        if (points[0] instanceof Point)\n        {\n            const p = [];\n\n            for (let i = 0, il = points.length; i < il; i++)\n            {\n                p.push(points[i].x, points[i].y);\n            }\n\n            points = p;\n        }\n\n        this.closed = true;\n\n        /**\n         * An array of the points of this polygon\n         *\n         * @member {number[]}\n         */\n        this.points = points;\n\n        /**\n         * The type of the object, mainly used to avoid `instanceof` checks\n         *\n         * @member {number}\n         * @readOnly\n         * @default PIXI.SHAPES.POLY\n         * @see PIXI.SHAPES\n         */\n        this.type = SHAPES.POLY;\n    }\n\n    /**\n     * Creates a clone of this polygon\n     *\n     * @return {PIXI.Polygon} a copy of the polygon\n     */\n    clone()\n    {\n        return new Polygon(this.points.slice());\n    }\n\n    /**\n     * Closes the polygon, adding points if necessary.\n     *\n     */\n    close()\n    {\n        const points = this.points;\n\n        // close the poly if the value is true!\n        if (points[0] !== points[points.length - 2] || points[1] !== points[points.length - 1])\n        {\n            points.push(points[0], points[1]);\n        }\n    }\n\n    /**\n     * Checks whether the x and y coordinates passed to this function are contained within this polygon\n     *\n     * @param {number} x - The X coordinate of the point to test\n     * @param {number} y - The Y coordinate of the point to test\n     * @return {boolean} Whether the x/y coordinates are within this polygon\n     */\n    contains(x, y)\n    {\n        let inside = false;\n\n        // use some raycasting to test hits\n        // https://github.com/substack/point-in-polygon/blob/master/index.js\n        const length = this.points.length / 2;\n\n        for (let i = 0, j = length - 1; i < length; j = i++)\n        {\n            const xi = this.points[i * 2];\n            const yi = this.points[(i * 2) + 1];\n            const xj = this.points[j * 2];\n            const yj = this.points[(j * 2) + 1];\n            const intersect = ((yi > y) !== (yj > y)) && (x < ((xj - xi) * ((y - yi) / (yj - yi))) + xi);\n\n            if (intersect)\n            {\n                inside = !inside;\n            }\n        }\n\n        return inside;\n    }\n}\n"]}