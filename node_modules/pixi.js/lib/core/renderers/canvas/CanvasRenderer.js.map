{"version":3,"sources":["../../../../src/core/renderers/canvas/CanvasRenderer.js"],"names":["CanvasRenderer","options","arg2","arg3","type","CANVAS","rootContext","view","getContext","alpha","transparent","context","refresh","maskManager","smoothProperty","imageSmoothingEnabled","webkitImageSmoothingEnabled","mozImageSmoothingEnabled","oImageSmoothingEnabled","msImageSmoothingEnabled","initPlugins","blendModes","_activeBlendMode","renderingToScreen","resize","width","height","render","displayObject","renderTexture","clear","transform","skipUpdateTransform","emit","rootResolution","resolution","baseTexture","_canvasRenderTarget","source","canvas","valid","_lastObjectRendered","cacheParent","parent","tempWt","_tempDisplayObjectParent","worldTransform","copy","_worldID","identity","updateTransform","save","setTransform","globalAlpha","NORMAL","globalCompositeOperation","navigator","isCocoonJS","screencanvas","fillStyle","undefined","clearBeforeRender","clearRect","_backgroundColorString","fillRect","tempContext","renderCanvas","restore","clearColor","setBlendMode","blendMode","destroy","removeView","destroyPlugins","screenWidth","screenHeight","SCALE_MODE","LINEAR","invalidateBlendMode","indexOf","mixin"],"mappings":"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","file":"CanvasRenderer.js","sourcesContent":["import SystemRenderer from '../SystemRenderer';\nimport CanvasMaskManager from './utils/CanvasMaskManager';\nimport CanvasRenderTarget from './utils/CanvasRenderTarget';\nimport mapCanvasBlendModesToPixi from './utils/mapCanvasBlendModesToPixi';\nimport { pluginTarget } from '../../utils';\nimport { RENDERER_TYPE, SCALE_MODES, BLEND_MODES } from '../../const';\nimport settings from '../../settings';\n\n/**\n * The CanvasRenderer draws the scene and all its content onto a 2d canvas. This renderer should\n * be used for browsers that do not support WebGL. Don't forget to add the CanvasRenderer.view to\n * your DOM or you will not see anything :)\n *\n * @class\n * @memberof PIXI\n * @extends PIXI.SystemRenderer\n */\nexport default class CanvasRenderer extends SystemRenderer\n{\n    // eslint-disable-next-line valid-jsdoc\n    /**\n     * @param {object} [options] - The optional renderer parameters\n     * @param {number} [options.width=800] - the width of the screen\n     * @param {number} [options.height=600] - the height of the screen\n     * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional\n     * @param {boolean} [options.transparent=false] - If the render view is transparent, default false\n     * @param {boolean} [options.autoResize=false] - If the render view is automatically resized, default false\n     * @param {boolean} [options.antialias=false] - sets antialias (only applicable in chrome at the moment)\n     * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer. The\n     *  resolution of the renderer retina would be 2.\n     * @param {boolean} [options.preserveDrawingBuffer=false] - enables drawing buffer preservation,\n     *  enable this if you need to call toDataUrl on the webgl context.\n     * @param {boolean} [options.clearBeforeRender=true] - This sets if the renderer will clear the canvas or\n     *      not before the new render pass.\n     * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area\n     *  (shown if not transparent).\n     * @param {boolean} [options.roundPixels=false] - If true PixiJS will Math.floor() x/y values when rendering,\n     *  stopping pixel interpolation.\n     */\n    constructor(options, arg2, arg3)\n    {\n        super('Canvas', options, arg2, arg3);\n\n        this.type = RENDERER_TYPE.CANVAS;\n\n        /**\n         * The root canvas 2d context that everything is drawn with.\n         *\n         * @member {CanvasRenderingContext2D}\n         */\n        this.rootContext = this.view.getContext('2d', { alpha: this.transparent });\n\n        /**\n         * The currently active canvas 2d context (could change with renderTextures)\n         *\n         * @member {CanvasRenderingContext2D}\n         */\n        this.context = this.rootContext;\n\n        /**\n         * Boolean flag controlling canvas refresh.\n         *\n         * @member {boolean}\n         */\n        this.refresh = true;\n\n        /**\n         * Instance of a CanvasMaskManager, handles masking when using the canvas renderer.\n         *\n         * @member {PIXI.CanvasMaskManager}\n         */\n        this.maskManager = new CanvasMaskManager(this);\n\n        /**\n         * The canvas property used to set the canvas smoothing property.\n         *\n         * @member {string}\n         */\n        this.smoothProperty = 'imageSmoothingEnabled';\n\n        if (!this.rootContext.imageSmoothingEnabled)\n        {\n            if (this.rootContext.webkitImageSmoothingEnabled)\n            {\n                this.smoothProperty = 'webkitImageSmoothingEnabled';\n            }\n            else if (this.rootContext.mozImageSmoothingEnabled)\n            {\n                this.smoothProperty = 'mozImageSmoothingEnabled';\n            }\n            else if (this.rootContext.oImageSmoothingEnabled)\n            {\n                this.smoothProperty = 'oImageSmoothingEnabled';\n            }\n            else if (this.rootContext.msImageSmoothingEnabled)\n            {\n                this.smoothProperty = 'msImageSmoothingEnabled';\n            }\n        }\n\n        this.initPlugins();\n\n        this.blendModes = mapCanvasBlendModesToPixi();\n        this._activeBlendMode = null;\n\n        this.renderingToScreen = false;\n\n        this.resize(this.options.width, this.options.height);\n\n        /**\n         * Fired after rendering finishes.\n         *\n         * @event PIXI.CanvasRenderer#postrender\n         */\n\n        /**\n         * Fired before rendering starts.\n         *\n         * @event PIXI.CanvasRenderer#prerender\n         */\n    }\n\n    /**\n     * Renders the object to this canvas view\n     *\n     * @param {PIXI.DisplayObject} displayObject - The object to be rendered\n     * @param {PIXI.RenderTexture} [renderTexture] - A render texture to be rendered to.\n     *  If unset, it will render to the root context.\n     * @param {boolean} [clear=false] - Whether to clear the canvas before drawing\n     * @param {PIXI.Matrix} [transform] - A transformation to be applied\n     * @param {boolean} [skipUpdateTransform=false] - Whether to skip the update transform\n     */\n    render(displayObject, renderTexture, clear, transform, skipUpdateTransform)\n    {\n        if (!this.view)\n        {\n            return;\n        }\n\n        // can be handy to know!\n        this.renderingToScreen = !renderTexture;\n\n        this.emit('prerender');\n\n        const rootResolution = this.resolution;\n\n        if (renderTexture)\n        {\n            renderTexture = renderTexture.baseTexture || renderTexture;\n\n            if (!renderTexture._canvasRenderTarget)\n            {\n                renderTexture._canvasRenderTarget = new CanvasRenderTarget(\n                    renderTexture.width,\n                    renderTexture.height,\n                    renderTexture.resolution\n                );\n                renderTexture.source = renderTexture._canvasRenderTarget.canvas;\n                renderTexture.valid = true;\n            }\n\n            this.context = renderTexture._canvasRenderTarget.context;\n            this.resolution = renderTexture._canvasRenderTarget.resolution;\n        }\n        else\n        {\n            this.context = this.rootContext;\n        }\n\n        const context = this.context;\n\n        if (!renderTexture)\n        {\n            this._lastObjectRendered = displayObject;\n        }\n\n        if (!skipUpdateTransform)\n        {\n            // update the scene graph\n            const cacheParent = displayObject.parent;\n            const tempWt = this._tempDisplayObjectParent.transform.worldTransform;\n\n            if (transform)\n            {\n                transform.copy(tempWt);\n\n                // lets not forget to flag the parent transform as dirty...\n                this._tempDisplayObjectParent.transform._worldID = -1;\n            }\n            else\n            {\n                tempWt.identity();\n            }\n\n            displayObject.parent = this._tempDisplayObjectParent;\n\n            displayObject.updateTransform();\n            displayObject.parent = cacheParent;\n            // displayObject.hitArea = //TODO add a temp hit area\n        }\n\n        context.save();\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        context.globalAlpha = 1;\n        this._activeBlendMode = BLEND_MODES.NORMAL;\n        context.globalCompositeOperation = this.blendModes[BLEND_MODES.NORMAL];\n\n        if (navigator.isCocoonJS && this.view.screencanvas)\n        {\n            context.fillStyle = 'black';\n            context.clear();\n        }\n\n        if (clear !== undefined ? clear : this.clearBeforeRender)\n        {\n            if (this.renderingToScreen)\n            {\n                if (this.transparent)\n                {\n                    context.clearRect(0, 0, this.width, this.height);\n                }\n                else\n                {\n                    context.fillStyle = this._backgroundColorString;\n                    context.fillRect(0, 0, this.width, this.height);\n                }\n            } // else {\n            // TODO: implement background for CanvasRenderTarget or RenderTexture?\n            // }\n        }\n\n        // TODO RENDER TARGET STUFF HERE..\n        const tempContext = this.context;\n\n        this.context = context;\n        displayObject.renderCanvas(this);\n        this.context = tempContext;\n\n        context.restore();\n\n        this.resolution = rootResolution;\n\n        this.emit('postrender');\n    }\n\n    /**\n     * Clear the canvas of renderer.\n     *\n     * @param {string} [clearColor] - Clear the canvas with this color, except the canvas is transparent.\n     */\n    clear(clearColor)\n    {\n        const context = this.context;\n\n        clearColor = clearColor || this._backgroundColorString;\n\n        if (!this.transparent && clearColor)\n        {\n            context.fillStyle = clearColor;\n            context.fillRect(0, 0, this.width, this.height);\n        }\n        else\n        {\n            context.clearRect(0, 0, this.width, this.height);\n        }\n    }\n\n    /**\n     * Sets the blend mode of the renderer.\n     *\n     * @param {number} blendMode - See {@link PIXI.BLEND_MODES} for valid values.\n     */\n    setBlendMode(blendMode)\n    {\n        if (this._activeBlendMode === blendMode)\n        {\n            return;\n        }\n\n        this._activeBlendMode = blendMode;\n        this.context.globalCompositeOperation = this.blendModes[blendMode];\n    }\n\n    /**\n     * Removes everything from the renderer and optionally removes the Canvas DOM element.\n     *\n     * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.\n     */\n    destroy(removeView)\n    {\n        this.destroyPlugins();\n\n        // call the base destroy\n        super.destroy(removeView);\n\n        this.context = null;\n\n        this.refresh = true;\n\n        this.maskManager.destroy();\n        this.maskManager = null;\n\n        this.smoothProperty = null;\n    }\n\n    /**\n     * Resizes the canvas view to the specified width and height.\n     *\n     * @extends PIXI.SystemRenderer#resize\n     *\n     * @param {number} screenWidth - the new width of the screen\n     * @param {number} screenHeight - the new height of the screen\n     */\n    resize(screenWidth, screenHeight)\n    {\n        super.resize(screenWidth, screenHeight);\n\n        // reset the scale mode.. oddly this seems to be reset when the canvas is resized.\n        // surely a browser bug?? Let PixiJS fix that for you..\n        if (this.smoothProperty)\n        {\n            this.rootContext[this.smoothProperty] = (settings.SCALE_MODE === SCALE_MODES.LINEAR);\n        }\n    }\n\n    /**\n     * Checks if blend mode has changed.\n     */\n    invalidateBlendMode()\n    {\n        this._activeBlendMode = this.blendModes.indexOf(this.context.globalCompositeOperation);\n    }\n}\n\n/**\n * Collection of installed plugins. These are included by default in PIXI, but can be excluded\n * by creating a custom build. Consult the README for more information about creating custom\n * builds and excluding plugins.\n * @name PIXI.CanvasRenderer#plugins\n * @type {object}\n * @readonly\n * @property {PIXI.accessibility.AccessibilityManager} accessibility Support tabbing interactive elements.\n * @property {PIXI.extract.CanvasExtract} extract Extract image data from renderer.\n * @property {PIXI.interaction.InteractionManager} interaction Handles mouse, touch and pointer events.\n * @property {PIXI.prepare.CanvasPrepare} prepare Pre-render display objects.\n */\n\n/**\n * Adds a plugin to the renderer.\n *\n * @method PIXI.CanvasRenderer#registerPlugin\n * @param {string} pluginName - The name of the plugin.\n * @param {Function} ctor - The constructor function or class for the plugin.\n */\n\npluginTarget.mixin(CanvasRenderer);\n"]}