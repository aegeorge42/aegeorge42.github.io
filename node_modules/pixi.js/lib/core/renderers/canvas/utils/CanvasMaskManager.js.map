{"version":3,"sources":["../../../../../src/core/renderers/canvas/utils/CanvasMaskManager.js"],"names":["CanvasMaskManager","renderer","pushMask","maskData","context","save","cacheAlpha","alpha","transform","worldTransform","resolution","setTransform","a","b","c","d","tx","ty","_texture","renderGraphicsShape","clip","worldAlpha","graphics","len","graphicsData","length","beginPath","i","data","shape","type","POLY","points","holes","outerArea","innerArea","moveTo","j","lineTo","closePath","k","RECT","rect","x","y","width","height","CIRC","arc","radius","Math","PI","ELIP","w","h","kappa","ox","oy","xe","ye","xm","ym","bezierCurveTo","RREC","rx","ry","maxRadius","min","quadraticCurveTo","popMask","restore","invalidateBlendMode","destroy"],"mappings":"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","file":"CanvasMaskManager.js","sourcesContent":["import { SHAPES } from '../../../const';\n\n/**\n * A set of functions used to handle masking.\n *\n * @class\n * @memberof PIXI\n */\nexport default class CanvasMaskManager\n{\n    /**\n     * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.\n     */\n    constructor(renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * This method adds it to the current stack of masks.\n     *\n     * @param {object} maskData - the maskData that will be pushed\n     */\n    pushMask(maskData)\n    {\n        const renderer = this.renderer;\n\n        renderer.context.save();\n\n        const cacheAlpha = maskData.alpha;\n        const transform = maskData.transform.worldTransform;\n        const resolution = renderer.resolution;\n\n        renderer.context.setTransform(\n            transform.a * resolution,\n            transform.b * resolution,\n            transform.c * resolution,\n            transform.d * resolution,\n            transform.tx * resolution,\n            transform.ty * resolution\n        );\n\n        // TODO suport sprite alpha masks??\n        // lots of effort required. If demand is great enough..\n        if (!maskData._texture)\n        {\n            this.renderGraphicsShape(maskData);\n            renderer.context.clip();\n        }\n\n        maskData.worldAlpha = cacheAlpha;\n    }\n\n    /**\n     * Renders a PIXI.Graphics shape.\n     *\n     * @param {PIXI.Graphics} graphics - The object to render.\n     */\n    renderGraphicsShape(graphics)\n    {\n        const context = this.renderer.context;\n        const len = graphics.graphicsData.length;\n\n        if (len === 0)\n        {\n            return;\n        }\n\n        context.beginPath();\n\n        for (let i = 0; i < len; i++)\n        {\n            const data = graphics.graphicsData[i];\n            const shape = data.shape;\n\n            if (data.type === SHAPES.POLY)\n            {\n                let points = shape.points;\n                const holes = data.holes;\n                let outerArea;\n                let innerArea;\n\n                context.moveTo(points[0], points[1]);\n\n                for (let j = 2; j < points.length; j += 2)\n                {\n                    context.lineTo(points[j], points[j + 1]);\n                }\n\n                // if the first and last point are the same close the path - much neater :)\n                if (points[0] === points[points.length - 2] && points[1] === points[points.length - 1])\n                {\n                    context.closePath();\n                }\n\n                if (holes.length > 0)\n                {\n                    outerArea = 0;\n                    for (let j = 0; j < points.length; j += 2)\n                    {\n                        outerArea += (points[j] * points[j + 3]) - (points[j + 1] * points[j + 2]);\n                    }\n\n                    for (let k = 0; k < holes.length; k++)\n                    {\n                        points = holes[k].points;\n\n                        innerArea = 0;\n                        for (let j = 0; j < points.length; j += 2)\n                        {\n                            innerArea += (points[j] * points[j + 3]) - (points[j + 1] * points[j + 2]);\n                        }\n\n                        context.moveTo(points[0], points[1]);\n\n                        if (innerArea * outerArea < 0)\n                        {\n                            for (let j = 2; j < points.length; j += 2)\n                            {\n                                context.lineTo(points[j], points[j + 1]);\n                            }\n                        }\n                        else\n                        {\n                            for (let j = points.length - 2; j >= 2; j -= 2)\n                            {\n                                context.lineTo(points[j], points[j + 1]);\n                            }\n                        }\n                    }\n                }\n            }\n            else if (data.type === SHAPES.RECT)\n            {\n                context.rect(shape.x, shape.y, shape.width, shape.height);\n                context.closePath();\n            }\n            else if (data.type === SHAPES.CIRC)\n            {\n                // TODO - need to be Undefined!\n                context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);\n                context.closePath();\n            }\n            else if (data.type === SHAPES.ELIP)\n            {\n                // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\n\n                const w = shape.width * 2;\n                const h = shape.height * 2;\n\n                const x = shape.x - (w / 2);\n                const y = shape.y - (h / 2);\n\n                const kappa = 0.5522848;\n                const ox = (w / 2) * kappa; // control point offset horizontal\n                const oy = (h / 2) * kappa; // control point offset vertical\n                const xe = x + w;           // x-end\n                const ye = y + h;           // y-end\n                const xm = x + (w / 2);       // x-middle\n                const ym = y + (h / 2);       // y-middle\n\n                context.moveTo(x, ym);\n                context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n                context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n                context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n                context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n                context.closePath();\n            }\n            else if (data.type === SHAPES.RREC)\n            {\n                const rx = shape.x;\n                const ry = shape.y;\n                const width = shape.width;\n                const height = shape.height;\n                let radius = shape.radius;\n\n                const maxRadius = Math.min(width, height) / 2 | 0;\n\n                radius = radius > maxRadius ? maxRadius : radius;\n\n                context.moveTo(rx, ry + radius);\n                context.lineTo(rx, ry + height - radius);\n                context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);\n                context.lineTo(rx + width - radius, ry + height);\n                context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);\n                context.lineTo(rx + width, ry + radius);\n                context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);\n                context.lineTo(rx + radius, ry);\n                context.quadraticCurveTo(rx, ry, rx, ry + radius);\n                context.closePath();\n            }\n        }\n    }\n\n    /**\n     * Restores the current drawing context to the state it was before the mask was applied.\n     *\n     * @param {PIXI.CanvasRenderer} renderer - The renderer context to use.\n     */\n    popMask(renderer)\n    {\n        renderer.context.restore();\n        renderer.invalidateBlendMode();\n    }\n\n    /**\n     * Destroys this canvas mask manager.\n     *\n     */\n    destroy()\n    {\n        /* empty */\n    }\n}\n"]}