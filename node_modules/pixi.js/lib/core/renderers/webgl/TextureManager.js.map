{"version":3,"sources":["../../../../src/core/renderers/webgl/TextureManager.js"],"names":["TextureManager","renderer","gl","_managedTextures","bindTexture","getTexture","updateTexture","texture","location","isRenderTexture","_glRenderTargets","hasLoaded","boundTextures","undefined","i","length","activeTexture","TEXTURE0","glTexture","_glTextures","CONTEXT_UID","renderTarget","width","height","scaleMode","resolution","resize","_activeRenderTarget","root","frameBuffer","bind","premultiplyAlpha","upload","source","on","destroyTexture","push","isPowerOfTwo","mipmap","enableMipmap","wrapMode","CLAMP","enableWrapClamp","REPEAT","enableWrapRepeat","enableWrapMirrorRepeat","NEAREST","enableNearestScaling","enableLinearScaling","skipRemove","baseTexture","uid","glTextures","glRenderTargets","unbindTexture","destroy","off","indexOf","bindRenderTarget","rootRenderTarget","removeAll"],"mappings":"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","file":"TextureManager.js","sourcesContent":["import { GLTexture } from 'pixi-gl-core';\nimport { WRAP_MODES, SCALE_MODES } from '../../const';\nimport RenderTarget from './utils/RenderTarget';\nimport { removeItems } from '../../utils';\n\n/**\n * Helper class to create a webGL Texture\n *\n * @class\n * @memberof PIXI\n */\nexport default class TextureManager\n{\n    /**\n     * @param {PIXI.WebGLRenderer} renderer - A reference to the current renderer\n     */\n    constructor(renderer)\n    {\n        /**\n         * A reference to the current renderer\n         *\n         * @member {PIXI.WebGLRenderer}\n         */\n        this.renderer = renderer;\n\n        /**\n         * The current WebGL rendering context\n         *\n         * @member {WebGLRenderingContext}\n         */\n        this.gl = renderer.gl;\n\n        /**\n         * Track textures in the renderer so we can no longer listen to them on destruction.\n         *\n         * @member {Array<*>}\n         * @private\n         */\n        this._managedTextures = [];\n    }\n\n    /**\n     * Binds a texture.\n     *\n     */\n    bindTexture()\n    {\n        // empty\n    }\n\n    /**\n     * Gets a texture.\n     *\n     */\n    getTexture()\n    {\n        // empty\n    }\n\n    /**\n     * Updates and/or Creates a WebGL texture for the renderer's context.\n     *\n     * @param {PIXI.BaseTexture|PIXI.Texture} texture - the texture to update\n     * @param {number} location - the location the texture will be bound to.\n     * @return {GLTexture} The gl texture.\n     */\n    updateTexture(texture, location)\n    {\n        // assume it good!\n        // texture = texture.baseTexture || texture;\n\n        const gl = this.gl;\n\n        const isRenderTexture = !!texture._glRenderTargets;\n\n        if (!texture.hasLoaded)\n        {\n            return null;\n        }\n\n        const boundTextures = this.renderer.boundTextures;\n\n        // if the location is undefined then this may have been called by n event.\n        // this being the case the texture may already be bound to a slot. As a texture can only be bound once\n        // we need to find its current location if it exists.\n        if (location === undefined)\n        {\n            location = 0;\n\n            // TODO maybe we can use texture bound ids later on...\n            // check if texture is already bound..\n            for (let i = 0; i < boundTextures.length; ++i)\n            {\n                if (boundTextures[i] === texture)\n                {\n                    location = i;\n                    break;\n                }\n            }\n        }\n\n        boundTextures[location] = texture;\n\n        gl.activeTexture(gl.TEXTURE0 + location);\n\n        let glTexture = texture._glTextures[this.renderer.CONTEXT_UID];\n\n        if (!glTexture)\n        {\n            if (isRenderTexture)\n            {\n                const renderTarget = new RenderTarget(\n                    this.gl,\n                    texture.width,\n                    texture.height,\n                    texture.scaleMode,\n                    texture.resolution\n                );\n\n                renderTarget.resize(texture.width, texture.height);\n                texture._glRenderTargets[this.renderer.CONTEXT_UID] = renderTarget;\n                glTexture = renderTarget.texture;\n\n                // framebuffer constructor disactivates current framebuffer\n                if (!this.renderer._activeRenderTarget.root)\n                {\n                    this.renderer._activeRenderTarget.frameBuffer.bind();\n                }\n            }\n            else\n            {\n                glTexture = new GLTexture(this.gl, null, null, null, null);\n                glTexture.bind(location);\n                glTexture.premultiplyAlpha = true;\n                glTexture.upload(texture.source);\n            }\n\n            texture._glTextures[this.renderer.CONTEXT_UID] = glTexture;\n\n            texture.on('update', this.updateTexture, this);\n            texture.on('dispose', this.destroyTexture, this);\n\n            this._managedTextures.push(texture);\n\n            if (texture.isPowerOfTwo)\n            {\n                if (texture.mipmap)\n                {\n                    glTexture.enableMipmap();\n                }\n\n                if (texture.wrapMode === WRAP_MODES.CLAMP)\n                {\n                    glTexture.enableWrapClamp();\n                }\n                else if (texture.wrapMode === WRAP_MODES.REPEAT)\n                {\n                    glTexture.enableWrapRepeat();\n                }\n                else\n                {\n                    glTexture.enableWrapMirrorRepeat();\n                }\n            }\n            else\n            {\n                glTexture.enableWrapClamp();\n            }\n\n            if (texture.scaleMode === SCALE_MODES.NEAREST)\n            {\n                glTexture.enableNearestScaling();\n            }\n            else\n            {\n                glTexture.enableLinearScaling();\n            }\n        }\n        // the texture already exists so we only need to update it..\n        else if (isRenderTexture)\n        {\n            texture._glRenderTargets[this.renderer.CONTEXT_UID].resize(texture.width, texture.height);\n        }\n        else\n        {\n            glTexture.upload(texture.source);\n        }\n\n        return glTexture;\n    }\n\n    /**\n     * Deletes the texture from WebGL\n     *\n     * @param {PIXI.BaseTexture|PIXI.Texture} texture - the texture to destroy\n     * @param {boolean} [skipRemove=false] - Whether to skip removing the texture from the TextureManager.\n     */\n    destroyTexture(texture, skipRemove)\n    {\n        texture = texture.baseTexture || texture;\n\n        if (!texture.hasLoaded)\n        {\n            return;\n        }\n\n        const renderer = this.renderer;\n        const uid = renderer.CONTEXT_UID;\n        const glTextures = texture._glTextures;\n        const glRenderTargets = texture._glRenderTargets;\n\n        if (glTextures[uid])\n        {\n            renderer.unbindTexture(texture);\n\n            glTextures[uid].destroy();\n            texture.off('update', this.updateTexture, this);\n            texture.off('dispose', this.destroyTexture, this);\n\n            delete glTextures[uid];\n\n            if (!skipRemove)\n            {\n                const i = this._managedTextures.indexOf(texture);\n\n                if (i !== -1)\n                {\n                    removeItems(this._managedTextures, i, 1);\n                }\n            }\n        }\n\n        if (glRenderTargets && glRenderTargets[uid])\n        {\n            if (renderer._activeRenderTarget === glRenderTargets[uid])\n            {\n                renderer.bindRenderTarget(renderer.rootRenderTarget);\n            }\n\n            glRenderTargets[uid].destroy();\n            delete glRenderTargets[uid];\n        }\n    }\n\n    /**\n     * Deletes all the textures from WebGL\n     */\n    removeAll()\n    {\n        // empty all the old gl textures as they are useless now\n        for (let i = 0; i < this._managedTextures.length; ++i)\n        {\n            const texture = this._managedTextures[i];\n\n            if (texture._glTextures[this.renderer.CONTEXT_UID])\n            {\n                delete texture._glTextures[this.renderer.CONTEXT_UID];\n            }\n        }\n    }\n\n    /**\n     * Destroys this manager and removes all its textures\n     */\n    destroy()\n    {\n        // destroy managed textures\n        for (let i = 0; i < this._managedTextures.length; ++i)\n        {\n            const texture = this._managedTextures[i];\n\n            this.destroyTexture(texture, true);\n\n            texture.off('update', this.updateTexture, this);\n            texture.off('dispose', this.destroyTexture, this);\n        }\n\n        this._managedTextures = null;\n    }\n}\n"]}