{"version":3,"sources":["../../../../../../src/core/renderers/webgl/filters/spriteMask/SpriteMaskFilter.js"],"names":["SpriteMaskFilter","sprite","maskMatrix","renderable","maskSprite","apply","filterManager","input","output","clear","tex","texture","valid","transform","update","uniforms","mask","otherMatrix","calculateSpriteMatrix","prepend","mapCoord","alpha","worldAlpha","maskClamp","uClampFrame","applyFilter"],"mappings":";;;;AAAA;;;;AACA;;AAEA;;AACA;;;;;;;;;;;;AAEA;;;;;;;IAOqBA,gB;;;AAEjB;;;AAGA,8BAAYC,MAAZ,EACA;AAAA;;AACI,YAAMC,aAAa,kBAAnB;;AADJ,qDAGI,y+BAHJ;;AAQID,eAAOE,UAAP,GAAoB,KAApB;;AAEA,cAAKC,UAAL,GAAkBH,MAAlB;AACA,cAAKC,UAAL,GAAkBA,UAAlB;AAXJ;AAYC;;AAED;;;;;;;;;;+BAQAG,K,kBAAMC,a,EAAeC,K,EAAOC,M,EAAQC,K,EACpC;AACI,YAAML,aAAa,KAAKA,UAAxB;AACA,YAAMM,MAAM,KAAKN,UAAL,CAAgBO,OAA5B;;AAEA,YAAI,CAACD,IAAIE,KAAT,EACA;AACI;AACH;AACD,YAAI,CAACF,IAAIG,SAAT,EACA;AACI;AACA;AACAH,gBAAIG,SAAJ,GAAgB,4BAAkBH,GAAlB,EAAuB,GAAvB,CAAhB;AACH;AACDA,YAAIG,SAAJ,CAAcC,MAAd;;AAEA,aAAKC,QAAL,CAAcC,IAAd,GAAqBN,GAArB;AACA,aAAKK,QAAL,CAAcE,WAAd,GAA4BX,cAAcY,qBAAd,CAAoC,KAAKhB,UAAzC,EAAqDE,UAArD,EACvBe,OADuB,CACfT,IAAIG,SAAJ,CAAcO,QADC,CAA5B;AAEA,aAAKL,QAAL,CAAcM,KAAd,GAAsBjB,WAAWkB,UAAjC;AACA,aAAKP,QAAL,CAAcQ,SAAd,GAA0Bb,IAAIG,SAAJ,CAAcW,WAAxC;;AAEAlB,sBAAcmB,WAAd,CAA0B,IAA1B,EAAgClB,KAAhC,EAAuCC,MAAvC,EAA+CC,KAA/C;AACH,K;;;;;kBApDgBT,gB","file":"SpriteMaskFilter.js","sourcesContent":["import Filter from '../Filter';\nimport { Matrix } from '../../../../math';\nimport { readFileSync } from 'fs';\nimport { join } from 'path';\nimport { default as TextureMatrix } from '../../../../textures/TextureMatrix';\n\n/**\n * The SpriteMaskFilter class\n *\n * @class\n * @extends PIXI.Filter\n * @memberof PIXI\n */\nexport default class SpriteMaskFilter extends Filter\n{\n    /**\n     * @param {PIXI.Sprite} sprite - the target sprite\n     */\n    constructor(sprite)\n    {\n        const maskMatrix = new Matrix();\n\n        super(\n            readFileSync(join(__dirname, './spriteMaskFilter.vert'), 'utf8'),\n            readFileSync(join(__dirname, './spriteMaskFilter.frag'), 'utf8')\n        );\n\n        sprite.renderable = false;\n\n        this.maskSprite = sprite;\n        this.maskMatrix = maskMatrix;\n    }\n\n    /**\n     * Applies the filter\n     *\n     * @param {PIXI.FilterManager} filterManager - The renderer to retrieve the filter from\n     * @param {PIXI.RenderTarget} input - The input render target.\n     * @param {PIXI.RenderTarget} output - The target to output to.\n     * @param {boolean} clear - Should the output be cleared before rendering to it\n     */\n    apply(filterManager, input, output, clear)\n    {\n        const maskSprite = this.maskSprite;\n        const tex = this.maskSprite.texture;\n\n        if (!tex.valid)\n        {\n            return;\n        }\n        if (!tex.transform)\n        {\n            // margin = 0.0, let it bleed a bit, shader code becomes easier\n            // assuming that atlas textures were made with 1-pixel padding\n            tex.transform = new TextureMatrix(tex, 0.0);\n        }\n        tex.transform.update();\n\n        this.uniforms.mask = tex;\n        this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite)\n            .prepend(tex.transform.mapCoord);\n        this.uniforms.alpha = maskSprite.worldAlpha;\n        this.uniforms.maskClamp = tex.transform.uClampFrame;\n\n        filterManager.applyFilter(this, input, output, clear);\n    }\n}\n"]}