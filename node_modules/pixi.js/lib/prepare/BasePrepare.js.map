{"version":3,"sources":["../../src/prepare/BasePrepare.js"],"names":["core","SharedTicker","ticker","shared","settings","UPLOADS_PER_FRAME","BasePrepare","renderer","limiter","uploadHookHelper","queue","addHooks","uploadHooks","completes","ticking","delayedTick","prepareItems","registerFindHook","findText","findTextStyle","findMultipleBaseTextures","findBaseTexture","findTexture","registerUploadHook","drawText","calculateTextStyle","upload","item","done","add","length","push","addOnce","tick","UPDATE_PRIORITY","UTILITY","setTimeout","beginFrame","allowedToUpload","uploaded","_destroyed","i","len","shift","slice","addHook","uploadHook","Container","children","destroy","remove","result","_textures","Texture","baseTexture","indexOf","BaseTexture","_texture","texture","helper","Text","updateText","TextStyle","font","toFontString","TextMetrics","measureFont","style"],"mappings":"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","file":"BasePrepare.js","sourcesContent":["import * as core from '../core';\nimport CountLimiter from './limiters/CountLimiter';\nconst SharedTicker = core.ticker.shared;\n\n/**\n * Default number of uploads per frame using prepare plugin.\n *\n * @static\n * @memberof PIXI.settings\n * @name UPLOADS_PER_FRAME\n * @type {number}\n * @default 4\n */\ncore.settings.UPLOADS_PER_FRAME = 4;\n\n/**\n * The prepare manager provides functionality to upload content to the GPU. BasePrepare handles\n * basic queuing functionality and is extended by {@link PIXI.prepare.WebGLPrepare} and {@link PIXI.prepare.CanvasPrepare}\n * to provide preparation capabilities specific to their respective renderers.\n *\n * @example\n * // Create a sprite\n * const sprite = new PIXI.Sprite.fromImage('something.png');\n *\n * // Load object into GPU\n * app.renderer.plugins.prepare.upload(sprite, () => {\n *\n *     //Texture(s) has been uploaded to GPU\n *     app.stage.addChild(sprite);\n *\n * })\n *\n * @abstract\n * @class\n * @memberof PIXI.prepare\n */\nexport default class BasePrepare\n{\n    /**\n     * @param {PIXI.SystemRenderer} renderer - A reference to the current renderer\n     */\n    constructor(renderer)\n    {\n        /**\n         * The limiter to be used to control how quickly items are prepared.\n         * @type {PIXI.prepare.CountLimiter|PIXI.prepare.TimeLimiter}\n         */\n        this.limiter = new CountLimiter(core.settings.UPLOADS_PER_FRAME);\n\n        /**\n         * Reference to the renderer.\n         * @type {PIXI.SystemRenderer}\n         * @protected\n         */\n        this.renderer = renderer;\n\n        /**\n         * The only real difference between CanvasPrepare and WebGLPrepare is what they pass\n         * to upload hooks. That different parameter is stored here.\n         * @type {PIXI.prepare.CanvasPrepare|PIXI.WebGLRenderer}\n         * @protected\n         */\n        this.uploadHookHelper = null;\n\n        /**\n         * Collection of items to uploads at once.\n         * @type {Array<*>}\n         * @private\n         */\n        this.queue = [];\n\n        /**\n         * Collection of additional hooks for finding assets.\n         * @type {Array<Function>}\n         * @private\n         */\n        this.addHooks = [];\n\n        /**\n         * Collection of additional hooks for processing assets.\n         * @type {Array<Function>}\n         * @private\n         */\n        this.uploadHooks = [];\n\n        /**\n         * Callback to call after completed.\n         * @type {Array<Function>}\n         * @private\n         */\n        this.completes = [];\n\n        /**\n         * If prepare is ticking (running).\n         * @type {boolean}\n         * @private\n         */\n        this.ticking = false;\n\n        /**\n         * 'bound' call for prepareItems().\n         * @type {Function}\n         * @private\n         */\n        this.delayedTick = () =>\n        {\n            // unlikely, but in case we were destroyed between tick() and delayedTick()\n            if (!this.queue)\n            {\n                return;\n            }\n            this.prepareItems();\n        };\n\n        // hooks to find the correct texture\n        this.registerFindHook(findText);\n        this.registerFindHook(findTextStyle);\n        this.registerFindHook(findMultipleBaseTextures);\n        this.registerFindHook(findBaseTexture);\n        this.registerFindHook(findTexture);\n\n        // upload hooks\n        this.registerUploadHook(drawText);\n        this.registerUploadHook(calculateTextStyle);\n    }\n\n    /**\n     * Upload all the textures and graphics to the GPU.\n     *\n     * @param {Function|PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text} item -\n     *        Either the container or display object to search for items to upload, the items to upload themselves,\n     *        or the callback function, if items have been added using `prepare.add`.\n     * @param {Function} [done] - Optional callback when all queued uploads have completed\n     */\n    upload(item, done)\n    {\n        if (typeof item === 'function')\n        {\n            done = item;\n            item = null;\n        }\n\n        // If a display object, search for items\n        // that we could upload\n        if (item)\n        {\n            this.add(item);\n        }\n\n        // Get the items for upload from the display\n        if (this.queue.length)\n        {\n            if (done)\n            {\n                this.completes.push(done);\n            }\n\n            if (!this.ticking)\n            {\n                this.ticking = true;\n                SharedTicker.addOnce(this.tick, this, core.UPDATE_PRIORITY.UTILITY);\n            }\n        }\n        else if (done)\n        {\n            done();\n        }\n    }\n\n    /**\n     * Handle tick update\n     *\n     * @private\n     */\n    tick()\n    {\n        setTimeout(this.delayedTick, 0);\n    }\n\n    /**\n     * Actually prepare items. This is handled outside of the tick because it will take a while\n     * and we do NOT want to block the current animation frame from rendering.\n     *\n     * @private\n     */\n    prepareItems()\n    {\n        this.limiter.beginFrame();\n        // Upload the graphics\n        while (this.queue.length && this.limiter.allowedToUpload())\n        {\n            const item = this.queue[0];\n            let uploaded = false;\n\n            if (item && !item._destroyed)\n            {\n                for (let i = 0, len = this.uploadHooks.length; i < len; i++)\n                {\n                    if (this.uploadHooks[i](this.uploadHookHelper, item))\n                    {\n                        this.queue.shift();\n                        uploaded = true;\n                        break;\n                    }\n                }\n            }\n\n            if (!uploaded)\n            {\n                this.queue.shift();\n            }\n        }\n\n        // We're finished\n        if (!this.queue.length)\n        {\n            this.ticking = false;\n\n            const completes = this.completes.slice(0);\n\n            this.completes.length = 0;\n\n            for (let i = 0, len = completes.length; i < len; i++)\n            {\n                completes[i]();\n            }\n        }\n        else\n        {\n            // if we are not finished, on the next rAF do this again\n            SharedTicker.addOnce(this.tick, this, core.UPDATE_PRIORITY.UTILITY);\n        }\n    }\n\n    /**\n     * Adds hooks for finding items.\n     *\n     * @param {Function} addHook - Function call that takes two parameters: `item:*, queue:Array`\n     *          function must return `true` if it was able to add item to the queue.\n     * @return {PIXI.BasePrepare} Instance of plugin for chaining.\n     */\n    registerFindHook(addHook)\n    {\n        if (addHook)\n        {\n            this.addHooks.push(addHook);\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds hooks for uploading items.\n     *\n     * @param {Function} uploadHook - Function call that takes two parameters: `prepare:CanvasPrepare, item:*` and\n     *          function must return `true` if it was able to handle upload of item.\n     * @return {PIXI.BasePrepare} Instance of plugin for chaining.\n     */\n    registerUploadHook(uploadHook)\n    {\n        if (uploadHook)\n        {\n            this.uploadHooks.push(uploadHook);\n        }\n\n        return this;\n    }\n\n    /**\n     * Manually add an item to the uploading queue.\n     *\n     * @param {PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text|*} item - Object to\n     *        add to the queue\n     * @return {PIXI.CanvasPrepare} Instance of plugin for chaining.\n     */\n    add(item)\n    {\n        // Add additional hooks for finding elements on special\n        // types of objects that\n        for (let i = 0, len = this.addHooks.length; i < len; i++)\n        {\n            if (this.addHooks[i](item, this.queue))\n            {\n                break;\n            }\n        }\n\n        // Get childen recursively\n        if (item instanceof core.Container)\n        {\n            for (let i = item.children.length - 1; i >= 0; i--)\n            {\n                this.add(item.children[i]);\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Destroys the plugin, don't use after this.\n     *\n     */\n    destroy()\n    {\n        if (this.ticking)\n        {\n            SharedTicker.remove(this.tick, this);\n        }\n        this.ticking = false;\n        this.addHooks = null;\n        this.uploadHooks = null;\n        this.renderer = null;\n        this.completes = null;\n        this.queue = null;\n        this.limiter = null;\n        this.uploadHookHelper = null;\n    }\n\n}\n\n/**\n * Built-in hook to find multiple textures from objects like AnimatedSprites.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Texture object was found.\n */\nfunction findMultipleBaseTextures(item, queue)\n{\n    let result = false;\n\n    // Objects with mutliple textures\n    if (item && item._textures && item._textures.length)\n    {\n        for (let i = 0; i < item._textures.length; i++)\n        {\n            if (item._textures[i] instanceof core.Texture)\n            {\n                const baseTexture = item._textures[i].baseTexture;\n\n                if (queue.indexOf(baseTexture) === -1)\n                {\n                    queue.push(baseTexture);\n                    result = true;\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\n/**\n * Built-in hook to find BaseTextures from Sprites.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Texture object was found.\n */\nfunction findBaseTexture(item, queue)\n{\n    // Objects with textures, like Sprites/Text\n    if (item instanceof core.BaseTexture)\n    {\n        if (queue.indexOf(item) === -1)\n        {\n            queue.push(item);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to find textures from objects.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Texture object was found.\n */\nfunction findTexture(item, queue)\n{\n    if (item._texture && item._texture instanceof core.Texture)\n    {\n        const texture = item._texture.baseTexture;\n\n        if (queue.indexOf(texture) === -1)\n        {\n            queue.push(texture);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to draw PIXI.Text to its texture.\n *\n * @private\n * @param {PIXI.WebGLRenderer|PIXI.CanvasPrepare} helper - Not used by this upload handler\n * @param {PIXI.DisplayObject} item - Item to check\n * @return {boolean} If item was uploaded.\n */\nfunction drawText(helper, item)\n{\n    if (item instanceof core.Text)\n    {\n        // updating text will return early if it is not dirty\n        item.updateText(true);\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to calculate a text style for a PIXI.Text object.\n *\n * @private\n * @param {PIXI.WebGLRenderer|PIXI.CanvasPrepare} helper - Not used by this upload handler\n * @param {PIXI.DisplayObject} item - Item to check\n * @return {boolean} If item was uploaded.\n */\nfunction calculateTextStyle(helper, item)\n{\n    if (item instanceof core.TextStyle)\n    {\n        const font = item.toFontString();\n\n        core.TextMetrics.measureFont(font);\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to find Text objects.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Text object was found.\n */\nfunction findText(item, queue)\n{\n    if (item instanceof core.Text)\n    {\n        // push the text style to prepare it - this can be really expensive\n        if (queue.indexOf(item.style) === -1)\n        {\n            queue.push(item.style);\n        }\n        // also push the text object so that we can render it (to canvas/texture) if needed\n        if (queue.indexOf(item) === -1)\n        {\n            queue.push(item);\n        }\n        // also push the Text's texture for upload to GPU\n        const texture = item._texture.baseTexture;\n\n        if (queue.indexOf(texture) === -1)\n        {\n            queue.push(texture);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to find TextStyle objects.\n *\n * @private\n * @param {PIXI.TextStyle} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.TextStyle object was found.\n */\nfunction findTextStyle(item, queue)\n{\n    if (item instanceof core.TextStyle)\n    {\n        if (queue.indexOf(item) === -1)\n        {\n            queue.push(item);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n"]}