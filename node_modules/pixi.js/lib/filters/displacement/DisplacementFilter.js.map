{"version":3,"sources":["../../../src/filters/displacement/DisplacementFilter.js"],"names":["core","DisplacementFilter","sprite","scale","maskMatrix","Matrix","renderable","maskSprite","uniforms","mapSampler","_texture","filterMatrix","x","y","undefined","Point","apply","filterManager","input","output","calculateSpriteMatrix","applyFilter","value","Filter"],"mappings":";;;;;;AAAA;;IAAYA,I;;AAEZ;;;;;;;;;;AAEA;;;;;;;;;;;IAWqBC,kB;;;AAEjB;;;;AAIA,gCAAYC,MAAZ,EAAoBC,KAApB,EACA;AAAA;;AACI,YAAMC,aAAa,IAAIJ,KAAKK,MAAT,EAAnB;;AAEAH,eAAOI,UAAP,GAAoB,KAApB;;AAHJ,qDAKI;AACI;AADJ;AAGI;AAHJ,0dALJ;;AAYI,cAAKC,UAAL,GAAkBL,MAAlB;AACA,cAAKE,UAAL,GAAkBA,UAAlB;;AAEA,cAAKI,QAAL,CAAcC,UAAd,GAA2BP,OAAOQ,QAAlC;AACA,cAAKF,QAAL,CAAcG,YAAd,GAA6BP,UAA7B;AACA,cAAKI,QAAL,CAAcL,KAAd,GAAsB,EAAES,GAAG,CAAL,EAAQC,GAAG,CAAX,EAAtB;;AAEA,YAAIV,UAAU,IAAV,IAAkBA,UAAUW,SAAhC,EACA;AACIX,oBAAQ,EAAR;AACH;;AAED,cAAKA,KAAL,GAAa,IAAIH,KAAKe,KAAT,CAAeZ,KAAf,EAAsBA,KAAtB,CAAb;AAxBJ;AAyBC;;AAED;;;;;;;;;iCAOAa,K,kBAAMC,a,EAAeC,K,EAAOC,M,EAC5B;AACI,aAAKX,QAAL,CAAcG,YAAd,GAA6BM,cAAcG,qBAAd,CAAoC,KAAKhB,UAAzC,EAAqD,KAAKG,UAA1D,CAA7B;AACA,aAAKC,QAAL,CAAcL,KAAd,CAAoBS,CAApB,GAAwB,KAAKT,KAAL,CAAWS,CAAnC;AACA,aAAKJ,QAAL,CAAcL,KAAd,CAAoBU,CAApB,GAAwB,KAAKV,KAAL,CAAWU,CAAnC;;AAEC;AACDI,sBAAcI,WAAd,CAA0B,IAA1B,EAAgCH,KAAhC,EAAuCC,MAAvC;AACH,K;;AAED;;;;;;;;;4BAMA;AACI,mBAAO,KAAKX,QAAL,CAAcC,UAArB;AACH,S;0BAEOa,K,EAAO;AACf;AACI,iBAAKd,QAAL,CAAcC,UAAd,GAA2Ba,KAA3B;AACH;;;;EAhE2CtB,KAAKuB,M;;kBAAhCtB,kB","file":"DisplacementFilter.js","sourcesContent":["import * as core from '../../core';\nimport { readFileSync } from 'fs';\nimport { join } from 'path';\n\n/**\n * The DisplacementFilter class uses the pixel values from the specified texture\n * (called the displacement map) to perform a displacement of an object. You can\n * use this filter to apply all manor of crazy warping effects. Currently the r\n * property of the texture is used to offset the x and the g property of the texture\n * is used to offset the y.\n *\n * @class\n * @extends PIXI.Filter\n * @memberof PIXI.filters\n */\nexport default class DisplacementFilter extends core.Filter\n{\n    /**\n     * @param {PIXI.Sprite} sprite - The sprite used for the displacement map. (make sure its added to the scene!)\n     * @param {number} scale - The scale of the displacement\n     */\n    constructor(sprite, scale)\n    {\n        const maskMatrix = new core.Matrix();\n\n        sprite.renderable = false;\n\n        super(\n            // vertex shader\n            readFileSync(join(__dirname, '../fragments/default-filter-matrix.vert'), 'utf8'),\n            // fragment shader\n            readFileSync(join(__dirname, './displacement.frag'), 'utf8')\n        );\n\n        this.maskSprite = sprite;\n        this.maskMatrix = maskMatrix;\n\n        this.uniforms.mapSampler = sprite._texture;\n        this.uniforms.filterMatrix = maskMatrix;\n        this.uniforms.scale = { x: 1, y: 1 };\n\n        if (scale === null || scale === undefined)\n        {\n            scale = 20;\n        }\n\n        this.scale = new core.Point(scale, scale);\n    }\n\n    /**\n     * Applies the filter.\n     *\n     * @param {PIXI.FilterManager} filterManager - The manager.\n     * @param {PIXI.RenderTarget} input - The input target.\n     * @param {PIXI.RenderTarget} output - The output target.\n     */\n    apply(filterManager, input, output)\n    {\n        this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);\n        this.uniforms.scale.x = this.scale.x;\n        this.uniforms.scale.y = this.scale.y;\n\n         // draw the filter...\n        filterManager.applyFilter(this, input, output);\n    }\n\n    /**\n     * The texture used for the displacement map. Must be power of 2 sized texture.\n     *\n     * @member {PIXI.Texture}\n     */\n    get map()\n    {\n        return this.uniforms.mapSampler;\n    }\n\n    set map(value) // eslint-disable-line require-jsdoc\n    {\n        this.uniforms.mapSampler = value;\n    }\n}\n"]}