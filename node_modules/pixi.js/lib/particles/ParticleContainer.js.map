{"version":3,"sources":["../../src/particles/ParticleContainer.js"],"names":["core","ParticleContainer","maxSize","properties","batchSize","autoResize","maxBatchSize","_properties","_maxSize","_batchSize","_glBuffers","_bufferUpdateIDs","_updateID","interactiveChildren","blendMode","BLEND_MODES","NORMAL","roundPixels","baseTexture","setProperties","_tint","tintRgb","Float32Array","tint","vertices","scale","position","rotation","uvs","alpha","updateTransform","displayObjectUpdateTransform","renderWebGL","renderer","visible","worldAlpha","children","length","renderable","_texture","hasLoaded","once","onChildrenChange","setObjectRenderer","plugins","particle","render","smallestChildIndex","bufferIndex","Math","floor","push","renderCanvas","context","transform","worldTransform","isRotated","positionX","positionY","finalWidth","finalHeight","setBlendMode","globalAlpha","i","child","frame","PI","setTransform","a","b","c","d","tx","resolution","ty","anchor","x","width","y","height","childTransform","drawImage","source","destroy","options","_buffers","value","Container"],"mappings":"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","file":"ParticleContainer.js","sourcesContent":["import * as core from '../core';\nimport { hex2rgb } from '../core/utils';\n\n/**\n * The ParticleContainer class is a really fast version of the Container built solely for speed,\n * so use when you need a lot of sprites or particles. The tradeoff of the ParticleContainer is that most advanced\n * functionality will not work. ParticleContainer implements the basic object transform (position, scale, rotation)\n * and some advanced functionality like tint (as of v4.5.6).\n * Other more advanced functionality like masking, children, filters, etc will not work on sprites in this batch.\n *\n * It's extremely easy to use :\n *\n * ```js\n * let container = new ParticleContainer();\n *\n * for (let i = 0; i < 100; ++i)\n * {\n *     let sprite = new PIXI.Sprite.fromImage(\"myImage.png\");\n *     container.addChild(sprite);\n * }\n * ```\n *\n * And here you have a hundred sprites that will be rendered at the speed of light.\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI.particles\n */\nexport default class ParticleContainer extends core.Container\n{\n    /**\n     * @param {number} [maxSize=1500] - The maximum number of particles that can be rendered by the container.\n     *  Affects size of allocated buffers.\n     * @param {object} [properties] - The properties of children that should be uploaded to the gpu and applied.\n     * @param {boolean} [properties.vertices=false] - When true, vertices be uploaded and applied.\n     *                  if sprite's ` scale/anchor/trim/frame/orig` is dynamic, please set `true`.\n     * @param {boolean} [properties.position=true] - When true, position be uploaded and applied.\n     * @param {boolean} [properties.rotation=false] - When true, rotation be uploaded and applied.\n     * @param {boolean} [properties.uvs=false] - When true, uvs be uploaded and applied.\n     * @param {boolean} [properties.tint=false] - When true, alpha and tint be uploaded and applied.\n     * @param {number} [batchSize=16384] - Number of particles per batch. If less than maxSize, it uses maxSize instead.\n     * @param {boolean} [autoResize=false] If true, container allocates more batches in case\n     *  there are more than `maxSize` particles.\n     */\n    constructor(maxSize = 1500, properties, batchSize = 16384, autoResize = false)\n    {\n        super();\n\n        // Making sure the batch size is valid\n        // 65535 is max vertex index in the index buffer (see ParticleRenderer)\n        // so max number of particles is 65536 / 4 = 16384\n        const maxBatchSize = 16384;\n\n        if (batchSize > maxBatchSize)\n        {\n            batchSize = maxBatchSize;\n        }\n\n        if (batchSize > maxSize)\n        {\n            batchSize = maxSize;\n        }\n\n        /**\n         * Set properties to be dynamic (true) / static (false)\n         *\n         * @member {boolean[]}\n         * @private\n         */\n        this._properties = [false, true, false, false, false];\n\n        /**\n         * @member {number}\n         * @private\n         */\n        this._maxSize = maxSize;\n\n        /**\n         * @member {number}\n         * @private\n         */\n        this._batchSize = batchSize;\n\n        /**\n         * @member {object<number, WebGLBuffer>}\n         * @private\n         */\n        this._glBuffers = {};\n\n        /**\n         * for every batch stores _updateID corresponding to the last change in that batch\n         * @member {number[]}\n         * @private\n         */\n        this._bufferUpdateIDs = [];\n\n        /**\n         * when child inserted, removed or changes position this number goes up\n         * @member {number[]}\n         * @private\n         */\n        this._updateID = 0;\n\n        /**\n         * @member {boolean}\n         *\n         */\n        this.interactiveChildren = false;\n\n        /**\n         * The blend mode to be applied to the sprite. Apply a value of `PIXI.BLEND_MODES.NORMAL`\n         * to reset the blend mode.\n         *\n         * @member {number}\n         * @default PIXI.BLEND_MODES.NORMAL\n         * @see PIXI.BLEND_MODES\n         */\n        this.blendMode = core.BLEND_MODES.NORMAL;\n\n        /**\n         * If true, container allocates more batches in case there are more than `maxSize` particles.\n         * @member {boolean}\n         * @default false\n         */\n        this.autoResize = autoResize;\n\n        /**\n         * Used for canvas renderering. If true then the elements will be positioned at the\n         * nearest pixel. This provides a nice speed boost.\n         *\n         * @member {boolean}\n         * @default true;\n         */\n        this.roundPixels = true;\n\n        /**\n         * The texture used to render the children.\n         *\n         * @readonly\n         * @member {BaseTexture}\n         */\n        this.baseTexture = null;\n\n        this.setProperties(properties);\n\n        /**\n         * The tint applied to the container.\n         * This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n         *\n         * @private\n         * @member {number}\n         * @default 0xFFFFFF\n         */\n        this._tint = 0;\n        this.tintRgb = new Float32Array(4);\n        this.tint = 0xFFFFFF;\n    }\n\n    /**\n     * Sets the private properties array to dynamic / static based on the passed properties object\n     *\n     * @param {object} properties - The properties to be uploaded\n     */\n    setProperties(properties)\n    {\n        if (properties)\n        {\n            this._properties[0] = 'vertices' in properties || 'scale' in properties\n                ? !!properties.vertices || !!properties.scale : this._properties[0];\n            this._properties[1] = 'position' in properties ? !!properties.position : this._properties[1];\n            this._properties[2] = 'rotation' in properties ? !!properties.rotation : this._properties[2];\n            this._properties[3] = 'uvs' in properties ? !!properties.uvs : this._properties[3];\n            this._properties[4] = 'tint' in properties || 'alpha' in properties\n                ? !!properties.tint || !!properties.alpha : this._properties[4];\n        }\n    }\n\n    /**\n     * Updates the object transform for rendering\n     *\n     * @private\n     */\n    updateTransform()\n    {\n        // TODO don't need to!\n        this.displayObjectUpdateTransform();\n        //  PIXI.Container.prototype.updateTransform.call( this );\n    }\n\n    /**\n     * The tint applied to the container. This is a hex value.\n     * A value of 0xFFFFFF will remove any tint effect.\n     ** IMPORTANT: This is a webGL only feature and will be ignored by the canvas renderer.\n     * @member {number}\n     * @default 0xFFFFFF\n     */\n    get tint()\n    {\n        return this._tint;\n    }\n\n    set tint(value) // eslint-disable-line require-jsdoc\n    {\n        this._tint = value;\n        hex2rgb(value, this.tintRgb);\n    }\n\n    /**\n     * Renders the container using the WebGL renderer\n     *\n     * @private\n     * @param {PIXI.WebGLRenderer} renderer - The webgl renderer\n     */\n    renderWebGL(renderer)\n    {\n        if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable)\n        {\n            return;\n        }\n\n        if (!this.baseTexture)\n        {\n            this.baseTexture = this.children[0]._texture.baseTexture;\n            if (!this.baseTexture.hasLoaded)\n            {\n                this.baseTexture.once('update', () => this.onChildrenChange(0));\n            }\n        }\n\n        renderer.setObjectRenderer(renderer.plugins.particle);\n        renderer.plugins.particle.render(this);\n    }\n\n    /**\n     * Set the flag that static data should be updated to true\n     *\n     * @private\n     * @param {number} smallestChildIndex - The smallest child index\n     */\n    onChildrenChange(smallestChildIndex)\n    {\n        const bufferIndex = Math.floor(smallestChildIndex / this._batchSize);\n\n        while (this._bufferUpdateIDs.length < bufferIndex)\n        {\n            this._bufferUpdateIDs.push(0);\n        }\n        this._bufferUpdateIDs[bufferIndex] = ++this._updateID;\n    }\n\n    /**\n     * Renders the object using the Canvas renderer\n     *\n     * @private\n     * @param {PIXI.CanvasRenderer} renderer - The canvas renderer\n     */\n    renderCanvas(renderer)\n    {\n        if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable)\n        {\n            return;\n        }\n\n        const context = renderer.context;\n        const transform = this.worldTransform;\n        let isRotated = true;\n\n        let positionX = 0;\n        let positionY = 0;\n\n        let finalWidth = 0;\n        let finalHeight = 0;\n\n        renderer.setBlendMode(this.blendMode);\n\n        context.globalAlpha = this.worldAlpha;\n\n        this.displayObjectUpdateTransform();\n\n        for (let i = 0; i < this.children.length; ++i)\n        {\n            const child = this.children[i];\n\n            if (!child.visible)\n            {\n                continue;\n            }\n\n            const frame = child._texture.frame;\n\n            context.globalAlpha = this.worldAlpha * child.alpha;\n\n            if (child.rotation % (Math.PI * 2) === 0)\n            {\n                // this is the fastest  way to optimise! - if rotation is 0 then we can avoid any kind of setTransform call\n                if (isRotated)\n                {\n                    context.setTransform(\n                        transform.a,\n                        transform.b,\n                        transform.c,\n                        transform.d,\n                        transform.tx * renderer.resolution,\n                        transform.ty * renderer.resolution\n                    );\n\n                    isRotated = false;\n                }\n\n                positionX = ((child.anchor.x) * (-frame.width * child.scale.x)) + child.position.x + 0.5;\n                positionY = ((child.anchor.y) * (-frame.height * child.scale.y)) + child.position.y + 0.5;\n\n                finalWidth = frame.width * child.scale.x;\n                finalHeight = frame.height * child.scale.y;\n            }\n            else\n            {\n                if (!isRotated)\n                {\n                    isRotated = true;\n                }\n\n                child.displayObjectUpdateTransform();\n\n                const childTransform = child.worldTransform;\n\n                if (renderer.roundPixels)\n                {\n                    context.setTransform(\n                        childTransform.a,\n                        childTransform.b,\n                        childTransform.c,\n                        childTransform.d,\n                        (childTransform.tx * renderer.resolution) | 0,\n                        (childTransform.ty * renderer.resolution) | 0\n                    );\n                }\n                else\n                {\n                    context.setTransform(\n                        childTransform.a,\n                        childTransform.b,\n                        childTransform.c,\n                        childTransform.d,\n                        childTransform.tx * renderer.resolution,\n                        childTransform.ty * renderer.resolution\n                    );\n                }\n\n                positionX = ((child.anchor.x) * (-frame.width)) + 0.5;\n                positionY = ((child.anchor.y) * (-frame.height)) + 0.5;\n\n                finalWidth = frame.width;\n                finalHeight = frame.height;\n            }\n\n            const resolution = child._texture.baseTexture.resolution;\n\n            context.drawImage(\n                child._texture.baseTexture.source,\n                frame.x * resolution,\n                frame.y * resolution,\n                frame.width * resolution,\n                frame.height * resolution,\n                positionX * renderer.resolution,\n                positionY * renderer.resolution,\n                finalWidth * renderer.resolution,\n                finalHeight * renderer.resolution\n            );\n        }\n    }\n\n    /**\n     * Destroys the container\n     *\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their\n     *  destroy method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the texture of the child sprite\n     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the base texture of the child sprite\n     */\n    destroy(options)\n    {\n        super.destroy(options);\n\n        if (this._buffers)\n        {\n            for (let i = 0; i < this._buffers.length; ++i)\n            {\n                this._buffers[i].destroy();\n            }\n        }\n\n        this._properties = null;\n        this._buffers = null;\n        this._bufferUpdateIDs = null;\n    }\n}\n"]}